<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react diff</title>
      <link href="2021/05/10/Code-Frontend-react-diff/"/>
      <url>2021/05/10/Code-Frontend-react-diff/</url>
      
        <content type="html"><![CDATA[<p>现代前端框架最基本的最广泛应用的就是<code>virtualDOM</code>和<code>Diff</code>算法。react的diff算法分三种层面做了优化<code>tree diff</code>、<code>component diff</code>、<code>element diff</code>。</p><p>本文实现对element diff的超简实现。</p><a id="more"></a><p>首先react对tree的对比处理是，tree中同层级的节点才会进行比较，不同级别则直接进行删除、添加</p><p>然后对形同层级中的组件进行对比处理。</p><ul><li>如果是同一类型组件，继续tree diff的方法遍历子节点</li><li>如果不是，则直接重新渲染组件</li></ul><p>最后对于相同节点的比较element diff。对于同级别diff中，有相同节点而位置不同对情况，react引入了key作为优化手段。详细可以<a href="https://zhuanlan.zhihu.com/p/20346379">看这里</a></p><h3 id="实现一个超简版的react-diff"><a href="#实现一个超简版的react-diff" class="headerlink" title="实现一个超简版的react diff"></a>实现一个超简版的react diff</h3><ul><li><p>创建virtualDOM，以及实现virtualDOM渲染DOM</p><figure class="highlight javascript"><figcaption><span>element.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, props, children</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">    <span class="built_in">this</span>.props = props</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(type, props, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">domObject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(domObjet.type)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> domObject.props)&#123;</span><br><span class="line">    setAttr(el, key, value)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  domObject.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    child = child <span class="keyword">instanceof</span> Element? render(child) : <span class="built_in">document</span>.createTextNode(child)</span><br><span class="line">    el.appendChild(child)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttr</span>(<span class="params">el, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>() &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;value&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">              el.tagName.toLowerCase() === <span class="string">&#x27;input&#x27;</span> || </span><br><span class="line">              el.tagName.toLowerCase() === <span class="string">&#x27;textarea&#x27;</span></span><br><span class="line">            ) &#123;</span><br><span class="line">              el.value = value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              el.setAttribute(key, value)</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;style&#x27;</span>:</span><br><span class="line">         el.style.cssText = value</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">         el.setAttribute(key, value)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderDOM</span>(<span class="params">el, target</span>) </span>&#123;</span><br><span class="line">  target.appendChild(el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">Element,</span><br><span class="line">  createElement,</span><br><span class="line">  setAttr,</span><br><span class="line">  renderDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建virtualDOM以及渲染到页面中</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createElement, render, renderDOM &#125; <span class="keyword">from</span> <span class="string">&#x27;element.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> virtualDom = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span>&#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, [<span class="string">&#x27;周杰伦&#x27;</span>]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, [<span class="string">&#x27;林俊杰&#x27;</span>]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, [<span class="string">&#x27;王力宏&#x27;</span>])</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = render(virtualDom);</span><br><span class="line"><span class="keyword">let</span> target = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">renderDOM(el, target)</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqeastsadvj318s09kjrr.jpg" style="zoom:33%;" /></li><li><p>当需要重新渲染如调用了<code>setState</code>后，对virtualDOM tree进行diff</p><figure class="highlight javascript"><figcaption><span>diff.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> patches = &#123;&#125;; <span class="comment">// 需要打的补丁</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// tree 顶层</span></span><br><span class="line">  walk(oldTree, newTree, index, patches);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">oldTree, newTree, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = []</span><br><span class="line">  <span class="keyword">if</span>(!newTree) &#123; <span class="comment">// 新树不存在，表示删除了整个节点</span></span><br><span class="line">    current.push(&#123;<span class="attr">type</span>: <span class="string">&#x27;REMOVE&#x27;</span>, index&#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> oldTree === <span class="string">&#x27;string&#x27;</span>&amp;&amp; <span class="keyword">typeof</span> newTree === <span class="string">&#x27;string&#x27;</span>) &#123; <span class="comment">// 字符串节点</span></span><br><span class="line">    <span class="keyword">if</span>(oldTree !== newTree) &#123;</span><br><span class="line">      current.push(&#123;<span class="attr">type</span>: <span class="string">&#x27;TEXT&#x27;</span>, <span class="attr">text</span>: newTree&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((oldTree&amp;&amp;oldTree.type) === (newTree&amp;&amp;newTree.type)) &#123;<span class="comment">// 类型相同，比较属性及子节点</span></span><br><span class="line">    <span class="keyword">let</span> attrObj = diffAttr(oldTree.props, newTree.props); <span class="comment">// 比较获得需要打补丁的属性</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(attrObj).length) &#123; <span class="comment">// 有属性补丁</span></span><br><span class="line">      current.push(&#123;<span class="attr">type</span>: <span class="string">&#x27;ATTR&#x27;</span>, <span class="attr">attr</span>: attrObj&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    diffChildren(oldTree.children, newTree.children, patches)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 节点被替换了</span></span><br><span class="line">     current.push(&#123;<span class="attr">type</span>: <span class="string">&#x27;REPLACE&#x27;</span>, newTree&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  patches[index] = current;<span class="comment">// 打入补丁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffAttr</span>(<span class="params">oldProps, newProps</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> patch = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> oldProps) &#123;<span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span>(oldProps[key] !== newProps[key]) &#123; <span class="comment">// 旧属性被修改、删除</span></span><br><span class="line">      patch[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> newProps) &#123;<span class="comment">// 遍历新属性，看是否有添加新属性</span></span><br><span class="line">    <span class="keyword">if</span>(!oldProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      patch[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> patch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>; <span class="comment">// 使用全局的索引</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChildren, newChildren, patches</span>) </span>&#123;</span><br><span class="line">  oldChildren.forEach(<span class="function">(<span class="params">child, index</span>) =&gt;</span> &#123;</span><br><span class="line">    walk(child, newChildren[index], num++, patches) <span class="comment">// 层级递增</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> diff</span><br></pre></td></tr></table></figure></li><li><p>添加一个virtualDOM，对比</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> diff <span class="keyword">from</span> <span class="string">&#x27;./diff.js&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> virtualDom2 = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;list-group&#x27;</span>&#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item active&#x27;</span>&#125;, [<span class="string">&#x27;七里香&#x27;</span>]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, [<span class="string">&#x27;一千年以后&#x27;</span>]),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, [<span class="string">&#x27;需要人陪&#x27;</span>])</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> patches = diff(virtualDom, virtualDom2);</span><br><span class="line"><span class="built_in">console</span>.log(patches)</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqec76h8kmj31qq0iqmxw.jpg" style="zoom:33%;" /></li><li><p>打补丁</p><figure class="highlight javascript"><figcaption><span>patch.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setAttr, render, Element &#125; <span class="keyword">from</span> <span class="string">&#x27;./element.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> allPatches;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">el, patches</span>) </span>&#123;</span><br><span class="line">  allPatches = &#123;...patches&#125;</span><br><span class="line">  </span><br><span class="line">  walk(el, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = allPatches[index++]</span><br><span class="line"> <span class="keyword">const</span> childNodes = el.childNodes</span><br><span class="line">  </span><br><span class="line">  childNodes.forEach(<span class="function"><span class="params">child</span> =&gt;</span> walk(child))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(current&amp;&amp;current.length) &#123; <span class="comment">// 有补丁</span></span><br><span class="line">    doPath(el, current)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPath</span>(<span class="params">el, patches</span>) </span>&#123;</span><br><span class="line">  patches.forEach(<span class="function"><span class="params">patch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(patch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;REMOVE&#x27;</span>:</span><br><span class="line">        el.parentNode.removeChild(el);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;TEXT&#x27;</span>:</span><br><span class="line">      el.textContent = patch.text</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;ATTR&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> patch.attr) &#123;</span><br><span class="line">          <span class="keyword">const</span> value = patch.attr[key]</span><br><span class="line">          <span class="keyword">if</span>(value) &#123;</span><br><span class="line">            setAttr(el, key, value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.removeAttribute(key)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;REPLACE&#x27;</span>:</span><br><span class="line">      <span class="keyword">let</span> newEl = patch.newTree</span><br><span class="line">        newEl = newEl <span class="keyword">instanceof</span> Element ? render(newEl) : <span class="built_in">document</span>.createTextNode(newEl)</span><br><span class="line">        el.parentNode.replaceChild(newEl, el)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> patch</span><br></pre></td></tr></table></figure></li><li><p>对DOM进行打补丁</p><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> patch <span class="keyword">from</span> <span class="string">&#x27;./patch.js&#x27;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">patch(el, patches);</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqeib5excxj30zq0ca74r.jpg" style="zoom:33%;" /></li></ul><p>至此完成了一个超简单版本对diff。</p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用hooks实现简易redux</title>
      <link href="2021/05/06/Code-Frontend-react-customRedux/"/>
      <url>2021/05/06/Code-Frontend-react-customRedux/</url>
      
        <content type="html"><![CDATA[<p>react 16.8新增了hooks，使得函数组件能够拥有自己的state，其中<code>useReducer</code>结合<code>createContext</code>可以实现一个简易的redux。基本思路是使用<code>useReducer</code>管理state，利用context的<code>Provider</code>组件透传state，从而实现跨组件管理state</p><a id="more"></a><ul><li><p>编写组件使用<code>useReducer</code>管理状态</p><figure class="highlight plain"><figcaption><span>reducer.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useReducer&#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">interface providerProps &#123;&#125;</span><br><span class="line">interface reducerState &#123;count: number&#125;</span><br><span class="line">interface reducerAction &#123;</span><br><span class="line">  type: string,</span><br><span class="line">  payload: &#123;[name: string]: any&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Actions &#123;</span><br><span class="line">  [name: string]: Reducer</span><br><span class="line">&#125;</span><br><span class="line">type Reducer &#x3D; (prevState: reducerState, action: reducerAction) &#x3D;&gt; reducerState</span><br><span class="line">type stateInit &#x3D; (state: reducerState) &#x3D;&gt; reducerState</span><br><span class="line"></span><br><span class="line">const actions: Actions &#x3D; &#123;</span><br><span class="line">  &#39;INCREASE&#39;: (prevState, action) &#x3D;&gt; (&#123;...prevState, count: prevState.count + 1&#125;)</span><br><span class="line">&#125;</span><br><span class="line">const reducer: Reducer &#x3D; (prevState, action) &#x3D;&gt; &#123;</span><br><span class="line">  const result &#x3D; actions[action.type]&amp;&amp;actions[action.type](prevState, action) || prevState</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">const initialState: reducerState &#x3D; &#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;</span><br><span class="line">const init: stateInit &#x3D; (state) &#x3D;&gt; &#123;</span><br><span class="line">  return state</span><br><span class="line">&#125;</span><br><span class="line">const Provider: React.FC&lt;providerProps&gt; &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState, init)</span><br><span class="line">  return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过<code>createContext</code>创建context，Provider，透传 reducerState给订阅组件</p><figure class="highlight plain"><figcaption><span>reducer.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useReducer&#125; from &#39;react&#39;</span><br><span class="line">...</span><br><span class="line">const context &#x3D; React.createContext&lt;&#123;state: reducerState, dispatch: (dispatcher: reducerAction) &#x3D;&gt; void&#125;&gt;(&#123;state: initialState, dispatch: () &#x3D;&gt; &#123;&#125;&#125;)</span><br><span class="line">const Provider: React.FC&lt;providerProps&gt; &#x3D; (&#123;children&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState, init)</span><br><span class="line">  return &lt;context.Provider value&#x3D;&#123;state, dispatch&#125;&gt;&#123;children&#125;&lt;&#x2F;context.Provider&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">Provider,</span><br><span class="line">  context,</span><br><span class="line">&#125; &#x2F;&#x2F; 导出Provider和context</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><figcaption><span>ComponentA.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useContext&#125; from &#39;react&#39;</span><br><span class="line">import &#123;context&#125; from &#39;.&#x2F;reducer.tsx&#39;</span><br><span class="line"></span><br><span class="line">export default function Index() &#123;</span><br><span class="line">  const &#123;state, dispatch&#125; &#x3D; useContext(context)</span><br><span class="line">  return &lt;div&gt;&#123;state.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>ComponentB.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useContext&#125; from &#39;react&#39;</span><br><span class="line">import &#123;context&#125; from &#39;.&#x2F;reducer.tsx&#39;</span><br><span class="line"></span><br><span class="line">export default function Index() &#123;</span><br><span class="line">  const &#123;state, dispatch&#125; &#x3D; useContext(context)</span><br><span class="line">  const handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: &#39;INCREASE&#39;,</span><br><span class="line">      payload: &#123;&#125;</span><br><span class="line">    &#125;) &#x2F;&#x2F; 分发一个action改变state，即可改变ComponentA</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;change state&lt;&#x2F;button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>Index.tsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useReducer&#125; from &#39;react&#39;</span><br><span class="line">import &#123;Provider&#125; from &#39;.&#x2F;reducer.tsx</span><br><span class="line">import ComponentA from &#39;.&#x2F;ComponentA&#39;</span><br><span class="line">import ComponentB from &#39;.&#x2F;ComponentB&#39;</span><br><span class="line"></span><br><span class="line">export default const Index &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return &lt;Provider&gt;</span><br><span class="line">  &lt;ComponentA &#x2F;&gt;</span><br><span class="line">    &lt;ComponentB &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Provider&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题</p><p>由于<code>context.Provider</code>的特点，当provider的value改变时，Provider下的所有组件都会重新渲染，带来性能问题</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 少用但有用的API总结（笔记）</title>
      <link href="2021/04/16/Code-Frontend-react-react-new/"/>
      <url>2021/04/16/Code-Frontend-react-react-new/</url>
      
        <content type="html"><![CDATA[<p>平常不太用到但有用到的react API总结（笔记），来源<a href="https://juejin.cn/post/6950063294270930980">掘金</a></p><a id="more"></a><h2 id="组件类API"><a href="#组件类API" class="headerlink" title="组件类API"></a>组件类API</h2><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>PureComponent 会做props浅层比较，未改变则不渲染组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class SonComponent extend React.PureComponent &#123;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;data&#125; &#x3D; this.props</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &#123;data.number&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Index extend React.Component &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      number: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;data&#125; &#x3D; this.state</span><br><span class="line">    data.number &#x3D; ++data.number</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      data &#x2F;&#x2F; data 的地址没有改变，不会重新渲染</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;SonComponent data&#x3D;&#123;this.state.data&#125;&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">      &lt;button onCLick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h3><p><code>memo</code>是一个高阶组件，可以包裹类组件和函数组件，接收两个参数，第一个为需要处理的组件，第二为可选参数，决定是否重新渲染的函数，有点类似componentShouldUpdate，缺省时默认对props作浅比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const Comp: React.FC&lt;&#123;number: number&#125;&gt; &#x3D; (&#123;number&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  return &lt;div&gt;&#123;number&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isEqual(prevProps, nextProps) &#123;</span><br><span class="line">  return prevProps.number !&#x3D;&#x3D; nextProps.number &amp;&amp; nextProps.number &gt; 5 &#x2F;&#x2F; 返回 true 时，不重新渲染，返回false时重新渲染，和componentShouldUpdate相反</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const SonComponent &#x3D; React.memo(Comp, isEqual)</span><br><span class="line"></span><br><span class="line">class Index extend React.Component &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    number: 1</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;number&#125; &#x3D; this.state</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      number: ++number</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;SonComponent data&#x3D;&#123;this.state.data&#125;&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">      &lt;button onCLick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>父组件修改子组件</p><p>通常情况下，父组件与子组件的交互通常是由<code>props</code>的单向数据流来决定，子组件中使用到的props数据决定了其如何渲染，通常情况下是不推荐父组件去使用子组件的方法来修改子组件，因为通常子组件作为一个独立的组件，有一定的封闭性，ref的使用会破坏这种封闭性，父组件调用子组件也不明确子组件内部的情况，带来很多不确定性。</p><blockquote><p>ref 是不可传递到属性，在子组件中获取props中的ref时，为undefined</p><p>ref在组件上时，ref指向组件实例，挂在DOM时，指向DOM</p></blockquote><ul><li><p><code>refs</code></p><p><strong>已弃用</strong>。官方不推荐使用refs，推荐使用 ref回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class index extend React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.refs.sonComponent &#x2F;&#x2F; 获取到子组件的实例</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;SonComponent ref&#x3D;&quot;sonComponent&quot;&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">      &lt;button onCLick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>ref=&#123;ref =&gt; this.ref = ref&#125;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class index extend React.Component &#123;</span><br><span class="line">  son &#x3D; null</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.refs.son &#x2F;&#x2F; 获取到子组件的实例</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;SonComponent ref&#x3D;&#123;ref &#x3D;&gt; this.son &#x3D; ref&#125;&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">      &lt;button onCLick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>回传子组件的实例<code>this</code>到父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class index extend React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  son &#x3D; null</span><br><span class="line">  </span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.refs.son &#x2F;&#x2F; 获取到子组件的实例</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;SonComponent onRef&#x3D;&#123;ref &#x3D;&gt; this.son &#x3D; ref&#125;&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">      &lt;button onCLick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SonComponent extend React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.props.onRef(this) &#x2F;&#x2F; 回调父组件方法</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;sonComponent&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>createRef</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class index extend React.Component &#123;</span><br><span class="line">  son &#x3D; React.ceateRef()</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.son.current &#x2F;&#x2F; 实例挂在current上</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;SonComponent ref&#x3D;&#123;this.son&#125;&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">      &lt;button onCLick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>forwardRef</code></p><p><code>forwardRef</code>的作用是传递ref。返回一个react组件</p><ul><li><p>类组件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface CompProps &#123;&#125;</span><br><span class="line">class Comp extend React.Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;sonComponent&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const SonComponent &#x3D; React.forwardRef&lt;Comp, CompProps&gt;((props, ref) &#x3D;&gt; &#123; &#x2F;&#x2F; forwardRef的类型需要注意，具体后续研究</span><br><span class="line"></span><br><span class="line">  return &lt;Comp &#123;...props&#125; ref&#x3D;&#123;ref&#125;&#x2F;&gt;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">class index extend React.Component &#123;</span><br><span class="line">  son &#x3D; React.ceateRef&lt;any&gt;() &#x2F;&#x2F; ref指向的类型，具体后续研究</span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.son.current &#x2F;&#x2F; 实例挂在current上</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;SonComponent ref&#x3D;&#123;this.son&#125;&gt;&lt;&#x2F;SonComponent&gt;</span><br><span class="line">      &lt;button onCLick&#x3D;&#123;this.handleClick&#125;&gt;click&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数组件中</p><p>函数组件不能接收ref</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Son: React.FC&lt;&#123;&#125;&gt; &#x3D; React.forwardRef((props, ref) &#x3D;&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  return &lt;div ref&#x3D;&#123;ref&#125;&gt;son&lt;&#x2F;div&gt;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function Father() &#123;</span><br><span class="line">  const ref &#x3D; useRef(null) &#x2F;&#x2F; ref.current -&gt; &lt;div&gt;son&lt;&#x2F;div&gt;</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">  &lt;Son ref&#x3D;&#123;ref&#125;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="lazy、Suspense"><a href="#lazy、Suspense" class="headerlink" title="lazy、Suspense"></a>lazy、Suspense</h3><p><code>React.lazy</code>和<code>Suspense</code>组合使用可以在组件加载中优雅降级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Component&#x2F;son.tsx</span><br><span class="line">class Son extend React.Component&lt;&#123;&#125;, &#123;&#125;&gt;&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    </span><br><span class="line">    return &lt;div&gt;son&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const newSon &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;Component&#x2F;son&#39;))</span><br><span class="line"></span><br><span class="line">class Father extend React.Component&lt;&#123;&#125;, &#123;&#125;&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    </span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">    something...</span><br><span class="line">      &lt;React.Suspense fallback&#x3D;&#123;&lt;div&gt;loading...&lt;&#x2F;div&gt;&#125;&gt;</span><br><span class="line">        &lt;newSon &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;React.Suspense&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lazy</code>和<code>Suspense</code>结合<code>react-router-dom</code>做代码分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));</span><br><span class="line">const AnotherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;AnotherComponent&#39;));</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;Loading...&lt;&#x2F;div&gt;&#125;&gt; &#123;&#x2F;*Suspense 组件可以包裹多个懒加载组件*&#x2F;&#125;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;OtherComponent &#x2F;&gt;</span><br><span class="line">          &lt;AnotherComponent &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;section&gt;</span><br><span class="line">      &lt;&#x2F;Suspense&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h3><p>组件可以包裹多个DOM片段，简写为<code>&lt;&gt;&lt;/&gt;</code>，区别是<code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code>可以使用key属性，未来可能会添加更多的支持，如事件。</p><h3 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a>Profiler</h3><p><code>Profiler</code>组件可以通过包裹组件来测量树中这部分渲染所需要的开销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const onRender &#x3D; function(</span><br><span class="line">    id: any, &#x2F;&#x2F; 发生提交的 Profiler 树的 “id”</span><br><span class="line">     phase: any, &#x2F;&#x2F; &quot;mount&quot; （如果组件树刚加载） 或者 &quot;update&quot; （如果它重渲染了）之一</span><br><span class="line">     actualDuration: any, &#x2F;&#x2F; 本次更新 committed 花费的渲染时间</span><br><span class="line">     baseDuration: any, &#x2F;&#x2F; 估计不使用 memoization 的情况下渲染整颗子树需要的时间</span><br><span class="line">     startTime: any, &#x2F;&#x2F; 本次更新中 React 开始渲染的时间</span><br><span class="line">     commitTime: any, &#x2F;&#x2F; 本次更新中 React committed 的时间</span><br><span class="line">     interactions: any &#x2F;&#x2F; 属于本次更新的 interactions 的集合</span><br><span class="line">  ) &#123;&#125;</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">  &lt;React.Profiler id&#x3D;&quot;profilerId&quot; onRender&#x3D;&#123;onRender&#125;&gt;</span><br><span class="line">      &lt;OtherComponent&gt;&lt;&#x2F;OtherComponent&gt;</span><br><span class="line">    &lt;&#x2F;React.Profiler&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h3><p>严格模式，检测react项目中潜在的问题，不会渲染任何UI组件。</p><ul><li>识别不安全的生命周期</li><li>使用过时的字符串 ref API 的警告</li><li>使用废弃的 findDOMNode 方法警告</li><li>检测意外的副作用</li><li>检测过时的 context API</li></ul><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h3><p>每个JSX 语法糖实际上是调用<code>React.createElement(component, props, children)</code>，这里<code>component</code>可以是组件、函数或普通dom的字符串；<code>props</code>是<code>component</code>的属性集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;Hello &#123;this.props.toWhat&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">&lt;Hello toWhat&#x3D;&quot;World&quot;&#x2F;&gt;,</span><br><span class="line">  document.getElemnetById(&#39;root&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不使用 JSX 则为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return React.createElement(&#39;div&#39;, null, &#96;Hello $&#123;this.props.toWhat&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">React.createElement(</span><br><span class="line">  Hello,</span><br><span class="line">    &#123;toWhat: &#39;World&#39;&#125;,</span><br><span class="line">    null</span><br><span class="line">  ),</span><br><span class="line">  documnet.getElementById(&#39;root&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement"></a>cloneElement</h3><p><code>React.cloneElement(element, [props], [...children])</code>，以element元素为模版克隆并返回新组件。返回元素的props是原始原素props和新props的浅层合并，原始原素的<code>key</code>和<code>ref</code>将被保留。用这个方法，<strong>可以劫持、混入新元素</strong>。劫持的典型案例：<code>react-router</code>的<code>Switch</code>组件通过 <code>path</code>来匹配组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Father extends React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;Son&gt;</span><br><span class="line">      &lt;GrandSon&gt;</span><br><span class="line">grandSon children</span><br><span class="line">      &lt;&#x2F;GrandSon&gt;</span><br><span class="line">    &lt;&#x2F;Son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;this is Son&lt;&#x2F;p&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        React.cloneElement(</span><br><span class="line">        this.props.children,</span><br><span class="line">          &#123;&#125;,</span><br><span class="line">          [</span><br><span class="line">            &#39;has been hijacked&#39;</span><br><span class="line">          ]</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GrandSon extends React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;p&gt;this is grandSon&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;&#123;this.props.children&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpp4iglzx4j308e05gwec.jpg" style="zoom:50%;" /><h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><p>创建<code>context</code>对象，提供给组件订阅这个对象，当context对象的值改变时，组件会从组件数中离自己最近的<code>context.Provider</code>中获取value的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MyContext.tsx</span><br><span class="line">const DEFAULT_VALUE &#x3D; &#123;name: &#39;Tim&#39;&#125;;</span><br><span class="line">export const MyContext &#x3D; React.createContext(DEFAULT_VALUE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app.tsx</span><br><span class="line">import MyContext from &#39;.&#x2F;MyContext&#39;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    name: &#39;Tom&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;MyContext.Provider value&#x3D;&#123;this.state&#125;&gt;</span><br><span class="line">    &lt;MyContext.Provider value&#x3D;&#123;&#123;name: &#39;Sam&#39;&#125;&#125;&gt;</span><br><span class="line">      &lt;ComponentA &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;MyContext.Provider&gt;</span><br><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">        &#123;value &#x3D;&gt; &lt;ComponentB &#123;...value&#125;&#x2F;&gt;&#125;</span><br><span class="line">      &lt;&#x2F;MyContext.Consumer&gt;</span><br><span class="line">    &lt;&#x2F;MyContext.Provider&gt;</span><br><span class="line">    &lt;ComponentC &#x2F;&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ComponentA.tsx</span><br><span class="line">import MyContext from &#39;.&#x2F;MyContext&#39;</span><br><span class="line">class ComponentA extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;&#123;this.context.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ComponentA.contextType &#x3D; MyContext</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ComponentB</span><br><span class="line">export default function ComponentB(props) &#123;</span><br><span class="line">  return &lt;div&gt;&#123;props.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ComponentC</span><br><span class="line">import MyContext from &#39;.&#x2F;MyContext&#39;</span><br><span class="line">export default function ComponentC() &#123;</span><br><span class="line">  const value &#x3D; useContext(MyContext);</span><br><span class="line">  return &lt;div&gt;&#123;value.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpq8g8p9nvj306o0bo3yf.jpg" style="zoom:50%;" /><h3 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement"></a>isValidElement</h3><p>检测是否为<code>react element</code>元素，返回 <code>true</code>或者 <code>false</code>。在一些公共组件处理时可以增强组件健壮性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const reactEle &#x3D; &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">const Component &#x3D; function() &#123;</span><br><span class="line">  return &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.isValidElement(reactEle) &#x2F;&#x2F; true</span><br><span class="line">React.isValidElement(Component) &#x2F;&#x2F; fasle</span><br></pre></td></tr></table></figure><h3 id="React-Children-相关的几个API"><a href="#React-Children-相关的几个API" class="headerlink" title="React.Children 相关的几个API"></a>React.Children 相关的几个API</h3><p><code>React.Children</code>提供了用于处理<code>this.props.children</code>不透明数据结构的几种方法</p><p>这里的不透明性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Text() &#123;</span><br><span class="line">  return &lt;div&gt;hello world&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WrapComponent(props) &#123;</span><br><span class="line">  conole.log(props.children)</span><br><span class="line">  return props.children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;WrapComponent&gt;</span><br><span class="line">    &lt;Text &#x2F;&gt;</span><br><span class="line">      &lt;Text &#x2F;&gt;</span><br><span class="line">      &lt;Text &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;WrapComponent&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时：</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpq99xxh77j3102064dgb.jpg" style="zoom:50%;" /><p>这种时透明的数据结构，我们可以直接遍历</p><p>修改<code>Index</code>的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Index() &#123;</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;WrapComponent&gt;</span><br><span class="line">      &#123;new Array(3).map(() &#x3D;&gt; &lt;Text &#x2F;&gt;)&#125;</span><br><span class="line">      &lt;span&gt;hello world&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;WrapComponent&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpq9dn445rj311u04q0st.jpg" style="zoom:50%;" /><p>这种结构我们不能正常遍历，需要借助<code>React.Children(props.children, item =&gt; tiem)</code></p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpq9jldsgzj311a05ojrv.jpg" style="zoom:50%;" /><blockquote><p>React.Fragment包裹的元素会被当作一个元素</p></blockquote><ul><li><p><code>React.Children.map(children, function)</code></p><p>在children的每个子节点上调用一个函数，如果子节点为<code>null</code>或<code>undefined</code>，则返回<code>null</code>或者<code>undefined</code>而不会调用函数</p></li><li><p><code>React.Children.forEach(children, function)</code></p><p>和<code>React.Children.map</code>相似，不会返回数组</p></li><li><p><code>React.Children.count(children)</code></p><p><code>children</code>中组件总数，<code>React.Children.map</code>的遍历次数</p></li><li><p><code>React.Children.only(children)</code></p><p>验证<code>children</code>是否只有一个子节点，有则返回节点，不是唯一则报错。</p></li><li><p><code>React.Children.toArray(children)</code></p><p>将<code>children</code>这个复杂结构扁平展开返回，并为每个成员添加一个key</p></li></ul><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>Hooks在另一篇记录</p><h2 id="ReactDom"><a href="#ReactDom" class="headerlink" title="ReactDom"></a>ReactDom</h2><ul><li><p><code>render</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(element, container[, callback])</span><br></pre></td></tr></table></figure></li><li><p><code>unmountComponentAtNode</code></p><p>从DOM中写在组件，会将组件的事件处理器和state一并清除。若容器内没有组件，函数返回false，成功移除则返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.unmountComponent(container); </span><br></pre></td></tr></table></figure><blockquote><p><code>unmountComponent</code>只可以卸载类似由<code>ReactDOM.render</code>渲染的组件</p></blockquote></li><li><p><code>createProtal</code></p><p>createProtal 是将子节点渲染到 DOM 节点中的方法，这个子节点可以存在于父节点之外</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Protal() &#123;</span><br><span class="line">  const ele &#x3D; &lt;div&gt;in body&lt;&#x2F;div&gt;</span><br><span class="line">  return ReactDOM.createProtal(ele, document.body);</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(Protal, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpthkrar2xj30vg0ckmxu.jpg" style="zoom:33%;" /><p>可以看到 <code>ele</code>节点被渲染到了body之中。全局弹窗组件<code>modal</code>可以用此方法实现挂载到body之中。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载</title>
      <link href="2021/02/03/Code-Frontend-javascript-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>2021/02/03/Code-Frontend-javascript-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>图片懒加载是前端比较普遍和使用广泛的用于优化性能的手段。基本原理是用户滚动页面到该图片之后才加载真实图片资源，达到延迟加载，减少不必要的资源浪费和性能损失。在这里记录下网上的，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>getBoundingClientRect</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API"><code>IntersectionObserver</code></a>，两种实现图片懒加载的方法。</p><a id="more"></a><h3 id="使用getBoundingClientRect获取视窗和图片的相对位置判断需要是否需要加载图片"><a href="#使用getBoundingClientRect获取视窗和图片的相对位置判断需要是否需要加载图片" class="headerlink" title="使用getBoundingClientRect获取视窗和图片的相对位置判断需要是否需要加载图片"></a>使用<code>getBoundingClientRect</code>获取视窗和图片的相对位置判断需要是否需要加载图片</h3><ul><li><p><code>getBoundingClientRect</code></p><p><code>Element.getBoundingClientRect()</code>方法返回元素的大小及其相对于视窗的位置。返回<code>DOMRect</code>对象。如果是标准盒模型，元素的尺寸等于<code>width/height</code> + <code>padding</code> + ‘border-width’；如果是<code>border-box</code>盒模型，元素的尺寸等于<code>width/height</code></p></li><li><p><code>DOMRect</code>对象</p><p><code>getBoundingClientRect</code>返回的矩形集合，包括<code>width</code>、<code>height</code>、<code>x</code>、<code>y</code>、<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这几个已像素为单位的只读属性。除<code>widht</code>和<code>height</code>属性以外，其余属性的计算都是由左上角开始。</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnafs48084j30dw0dwt94.jpg" style="zoom:50%;" /></li><li><p>实现</p><figure class="highlight html"><figcaption><span>getBoundingClientRect 图片懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.image-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>getBoundingClientRect 图片懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urlList = [</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=727460147,2222092211&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=2511982910,2454873241&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=825057118,3516313570&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3435942975,1552946865&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3569419905,626536365&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3779234486,1094031034&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=2763645735,2016465681&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3911840071,2534614245&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3908717,2002330211&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=318887420,2894941323&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=1063451194,1129125124&amp;fm=193&amp;f=GIF&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendImage</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nodes = urlList.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;img src=&quot;javascript:;&quot; class=&quot;image-item placeholder&quot; data-img=&quot;<span class="subst">$&#123;item&#125;</span>&quot;/&gt;`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  target.innerHTML = nodes.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;box&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.image-item[data-img]&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> boxTop = box.getBoundingClientRect().top</span><br><span class="line">  <span class="keyword">const</span> boxBottom = box.getBoundingClientRect().bottom</span><br><span class="line">  <span class="keyword">const</span> boxHeight = box.getBoundingClientRect().height</span><br><span class="line">  imgList.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> imgHeight = img.offsetHeight</span><br><span class="line">    <span class="keyword">let</span> imgTop = img.getBoundingClientRect().top</span><br><span class="line">    <span class="keyword">let</span> imgBottom = img.getBoundingClientRect().bottom</span><br><span class="line">    <span class="keyword">let</span> imgSrc = img.dataset.img</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(imgBottom&gt;=boxTop &amp;&amp; imgTop &lt; boxBottom) &#123;</span><br><span class="line">      img.setAttribute(<span class="string">&#x27;src&#x27;</span>, imgSrc)</span><br><span class="line">      img.classList.remove(<span class="string">&#x27;placeholder&#x27;</span>)</span><br><span class="line">      img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        img.removeAttribute(<span class="string">&#x27;data-img&#x27;</span>) <span class="comment">// 加载真实图片后删除属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boxScroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  lazyLoad(box)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">appendImage(box);</span><br><span class="line">lazyLoad(box); <span class="comment">// 初始化时需要调用一次</span></span><br><span class="line">box.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, boxScroll);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以用函数节流优化滚动事件的执行次数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ function throttle(fun, duration) &#123;</span></span><br><span class="line"><span class="addition">+ let preTime = 0</span></span><br><span class="line"><span class="addition">+ return function() &#123;</span></span><br><span class="line"><span class="addition">+ const now = Date.now()</span></span><br><span class="line"><span class="addition">+ const gapTime = now - preTime</span></span><br><span class="line"><span class="addition">+ const ags = arguments</span></span><br><span class="line"><span class="addition">+ if(gapTime &gt; duration) &#123;</span></span><br><span class="line"><span class="addition">+preTime = now</span></span><br><span class="line"><span class="addition">+fun&amp;&amp;fun.apply(this, ags)</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="deletion">- box.addEventListener(&#x27;scroll&#x27;, boxScroll);</span></span><br><span class="line"><span class="addition">+ box.addEventListener(&#x27;scroll&#x27;, throttle(boxScroll, 500));</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-IntersectionObserver-实现图片懒加载"><a href="#使用-IntersectionObserver-实现图片懒加载" class="headerlink" title="使用 IntersectionObserver 实现图片懒加载"></a>使用 <code>IntersectionObserver</code> 实现图片懒加载</h3><ul><li><p><code>IntersectionObserver</code>    </p><p>异步检测目标元素与根元素相交情况变化的方法</p><p>通常会在以下情况中使用到此方法</p><ul><li>图片懒加载——当图片滚动到可见时才进行加载</li><li>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li><li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li><li>在用户看见某个区域时执行任务或播放动画</li></ul><p>用例：</p><figure class="highlight javascript"><figcaption><span>IntersectionObserver</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> option = &#123;</span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#scroll-area&#x27;</span>),</span><br><span class="line">  rootMargin: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">  threshold: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(callBack, option); <span class="comment">// 当满足情况/初始化下，会执行 callBack</span></span><br><span class="line"><span class="keyword">let</span> target = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#listItem&#x27;</span>);</span><br><span class="line">observer.observe(target); <span class="comment">// 监听目标</span></span><br></pre></td></tr></table></figure><ul><li><p>option</p><ul><li><p>root：根元素，用于指定目标的可见性。必须是目标元素的<strong>父级元素</strong>。如果未指定或者为<code>null</code>，则默认为浏览器视窗。</p></li><li><p>rootMargin：根元素的计算交集的区域范围，与css的margin类似’10px 20px 30px 40px’；</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnagqu2a5sj30jq0fgglj.jpg" style="zoom:50%;" /></li><li><p>threshold：单一的number或number数组。target元素和root元素相交程度达到该值的时候IntersectionObserver注册的回调函数将会被执行。如果你只是想要探测当target元素的在root元素中的可见性超过50%的时候，你可以指定该属性值为0.5。如果你想要target元素在root元素的可见程度每多25%就执行一次回调，那么你可以指定一个数组[0, 0.25, 0.5, 0.75, 1]。默认值是0(意味着只要有一个target像素出现在root元素中，回调函数将会被执行)。该值为1.0含义是当target完全出现在root元素中时候 回调才会被执行。</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnahoj8at4j30jq0g3dfs.jpg" style="zoom:50%;" /><blockquote><p>只有当相交条件满足的时候才会执行callback获取到对象，大于或小于都不执行</p></blockquote></li><li><p>callback：每当目标满足该IntersectionObserver指定的threshold值，回调被调用。回调接收观察者的列表和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserver</code></a> 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback =<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Each entry describes an intersection change for one observed</span></span><br><span class="line">    <span class="comment">// target element:</span></span><br><span class="line">    <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">    <span class="comment">//   entry.isIntersecting</span></span><br><span class="line">    <span class="comment">//   entry.rootBounds</span></span><br><span class="line">    <span class="comment">//   entry.target</span></span><br><span class="line">    <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserver</code></a> 对象</p><p>当一个<code>IntersectionObserver</code>对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦IntersectionObserver被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。</p><ul><li>属性：<ul><li><code>IntersectionObserver.root</code></li><li><code>IntersectionObserver.rootMargin</code></li><li><code>IntersectionObserver.thresholds</code></li></ul></li><li>方法<ul><li><code>IntersectionObserver.disconnect()</code>：使<code>IntersectionObserver</code>对象停止监听工作。</li><li><code>IntersectionObserver.observe()</code>：使<code>IntersectionObserver</code>开始监听一个目标元素。</li><li><code>IntersectionObserver.takeRecords()</code>：返回所有观察目标的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserverEntry</code></a>对象数组。</li><li><code>IntersectionObserver.unobserve()</code>：使<code>IntersectionObserver</code>停止监听特定目标元素。</li></ul></li></ul></li></ul></li><li><p>实现</p><figure class="highlight javascript"><figcaption><span>IntersectionObserver 图片懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadObs</span>(<span class="params">option=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultOption = &#123;</span><br><span class="line">    root: <span class="literal">null</span>,</span><br><span class="line">    rootMargin: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">    threshold: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> imgUrl = img.getAttribute(<span class="string">&#x27;data-img&#x27;</span>)</span><br><span class="line">    img.setAttribute(<span class="string">&#x27;src&#x27;</span>, imgUrl)</span><br><span class="line">    img.classList.remove(<span class="string">&#x27;placeholder&#x27;</span>)</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      img.removeAttribute(<span class="string">&#x27;data-img&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="keyword">function</span>(<span class="params">IntersectionObserverEntry, observer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntersectionObserverEntry.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(img.isIntersecting) &#123; <span class="comment">// 满足相交条件</span></span><br><span class="line">        loadImage(img.target)</span><br><span class="line">        observer.unobserve(img.target) <span class="comment">// 取消监听</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;, <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOption, option))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> imgList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.image-item[data-img]&#x27;</span>)</span><br><span class="line">  imgList.forEach(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    observer.observe(img)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听执行</span></span><br><span class="line">lazyLoadObs(&#123;</span><br><span class="line">  root: box,</span><br><span class="line">  rootMargin: <span class="string">&#x27;0px 0px -50px 0px&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>IntersectionObserver</code>兼容性较差</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个记录</title>
      <link href="2020/12/11/%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95/"/>
      <url>2020/12/11/%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的EventLoop</title>
      <link href="2020/12/09/Code-Frontend-javascript-EventLoop/"/>
      <url>2020/12/09/Code-Frontend-javascript-EventLoop/</url>
      
        <content type="html"><![CDATA[<p>js通过事件队列实现异步调用，而事件队列就是 EventLoop 中的相关概念。本文简单说明 EventLoop 的过程</p><a id="more"></a><h2 id="JavaScript-的-Task和MicroTask"><a href="#JavaScript-的-Task和MicroTask" class="headerlink" title="JavaScript 的 Task和MicroTask"></a>JavaScript 的 <code>Task</code>和<code>MicroTask</code></h2><p>  在JavaScript中任务分 宏任务（MacroTask）也叫 Task ，和微任务（MicroTask）</p><ul><li><p>Task:</p><ul><li>JavaScript的所有代码</li><li>setTimeout</li><li>setInterval</li><li>I/O</li><li>UI Rendering</li></ul></li><li><p>MicroTask</p><ul><li>Process.nextTick（Node独有）</li><li>Promise</li><li>MutationObserver<a href="https://javascript.ruanyifeng.com/dom/mutationobserver.html">查看</a></li><li>Object.observe(废弃)</li></ul><blockquote><p>宿主环境提供的为宏任务，如setTimeout;语言标准提供的为微任务，如Promise；以此为记忆标准</p></blockquote></li></ul><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><p>  JavaScript 中有 <code>main thread</code>（主线程） 和 <code>call-stack</code>（调用栈）， 所有的任务都会被放入调用栈等待调用</p><h3 id="thread线程"><a href="#thread线程" class="headerlink" title="thread线程"></a><code>thread</code>线程</h3><ul><li><p>cpu、进程、线程</p><p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。 进程之间相互独立，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 CPU使用时间片轮转进度算法来实现同时运行多个进程。</p><p>线程就好比车间里的工人，一个进程可以包括多个线程，多个线程共享进程资源。</p><blockquote><p><code>进程</code>是cpu资源分配的最小单位</p></blockquote><blockquote><p><code>线程</code>是cpu调度的最小单位</p></blockquote><blockquote><p>不同线程可通信（代价较大</p></blockquote><blockquote><p><code>单线程</code>和<code>多线程</code>，是指在一个进程中的线程数</p></blockquote></li><li><p>javascript是单线程的，通过异步避免阻塞</p><h3 id="JavaScript-调用栈"><a href="#JavaScript-调用栈" class="headerlink" title="JavaScript 调用栈"></a>JavaScript 调用栈</h3><p>调用栈采用的是后进先出<code>LIFO</code>(Last In First Out)的规则， 当函数执行的时候，会创建一个执行上下文添加到栈的最顶端，当执行栈执行完后从栈移出，直到整个栈被清空</p><blockquote><p>调用栈空间是有限的，当调用栈中存有过多的函数而且没有释放时，就会出现爆栈<code>Maximum call stack size exceeded</code>的报错</p></blockquote><figure class="highlight javascript"><figcaption><span>调用栈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run first function&#x27;</span>);</span><br><span class="line">  second()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run first function again&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run second function&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">first() </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global&#x27;</span>);</span><br></pre></td></tr></table></figure><p>整个输出的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">run first function</span><br><span class="line">run second function</span><br><span class="line">run first function again</span><br><span class="line">global</span><br></pre></td></tr></table></figure><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>JavaScript的单线程任务分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程<strong>依次执行</strong>，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待<strong>主线程空闲的时候（调用栈被清空）</strong>，被读取到栈内等待主线程执行。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesx63fjicg311y0ryqv9.gif" alt="event-loop"></p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当点击 <code>inner</code> 时，会发生什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.outer&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.inner&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mutate&#x27;</span>)</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  outer.setAttribute(<span class="string">&#x27;data-random&#x27;</span>, <span class="built_in">Math</span>.random())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick)</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesxwqwuq6g311y0rye87.gif" alt="event-loop"></p><blockquote><p>这里冒泡阶段还是属于 inner 的 click 的处理，虽然调用栈 Stack 清空，这个 Task 并没有完成</p></blockquote></li></ul><h4 id="进阶2"><a href="#进阶2" class="headerlink" title="进阶2"></a>进阶2</h4><p>  当执行 <code>inner.click()</code> 会发生什么</p><p>  输出</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">click</span><br><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">promise</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesxdkerzlg311y0ryqva.gif" alt="event-loop"></p><blockquote><p>当第一次 <code>click</code> 执行完后，调用栈 <code>Stack </code>并没有清除，此时不能执行微任务 <code>MicroTask</code></p></blockquote><blockquote><p><code>MutationObserver</code> 并没有执行两此，因为上次的执行还在 <code>pending</code> 状态中</p></blockquote><h4 id="进阶3"><a href="#进阶3" class="headerlink" title="进阶3"></a>进阶3</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>  输出<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async2 end</span><br><span class="line">Promise</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p><blockquote><p>以上结果为chrome 73以上版本输出内容，73以下输出结果不一致</p></blockquote><h3 id="async-await和event-loop"><a href="#async-await和event-loop" class="headerlink" title="async await和event-loop"></a><code>async await</code>和<code>event-loop</code></h3><p>  简单了解<code>async await</code>到底干了什么        </p><ul><li><p><code>async</code></p><p><strong>一句话概括： 带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</strong></p><ul><li>如果 <code>async</code> 关键不是返回<code>primise</code>，会自动用<code>Promise.resolve()</code>包裹</li><li>如果<code>async</code>关键字函数显示地返回<code>promise</code>，就以函数返回的<code>promise</code>为准</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn1()) <span class="comment">// Promise &#123;&lt;resolved&gt;: 123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(fn2()) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>await</code></p><p><strong>一句话概括： await等的是右侧「表达式」的结果</strong></p><ul><li>如果右侧是函数，那么函数的<code>return</code>值就是整个<code>await</code>表达式的结果</li><li>如果右侧是表达式，那么整个<code>await</code>就是这个表达式的结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> fn2()</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这里<code>await</code>等待的结果，会根据是否是<code>promise</code>对象而有不同的处理</p><ul><li><p><code>promise</code>对象</p><p>阻塞后面的代码，跳出<code>async</code>中的代码，执行外面的同步代码。完成后回到<code>async</code>内部，再把这个结果，作为<code>await</code>表达式的结果</p></li><li><p>非<code>promise</code>对象</p><p>阻塞后面的代码，跳出<code>async</code>中的代码，执行外面的同步代码。完成后回到<code>async</code>内部，等待<code>promise</code>对象<code>fulfilled</code>,然后把<code>resolve</code>的结果最为<code>await</code>表达式的 结果</p><blockquote><p>从这部分说， <code>await</code>达式的运行，是从右边到左，先执行<code>await</code>后面的表达式，而并非直接跳出<code>async</code>函数</p></blockquote></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的EventLoop</title>
      <link href="2020/01/01/todoList/"/>
      <url>2020/01/01/todoList/</url>
      
        <content type="html"><![CDATA[<h3 id="好文收藏"><a href="#好文收藏" class="headerlink" title="好文收藏"></a>好文收藏</h3><ul><li>typescript<ul><li><input disabled="" type="checkbox"> TypeScript，初次见面，请多指教</li><li><input disabled="" type="checkbox"> 可能是你需要的 React + TypeScript 50 条规范和经验</li></ul></li><li>css<ul><li><input disabled="" type="checkbox"> css加载会造成阻塞吗</li></ul></li><li>前端工程<ul><li><input disabled="" type="checkbox"> 基于Webpack搭建React开发环境</li></ul></li><li>react<ul><li><input checked="" disabled="" type="checkbox"> 让虚拟DOM和DOM-diff不再成为你的绊脚石</li><li><input disabled="" type="checkbox"> React 源码剖析系列 － 不可思议的 react diff</li></ul></li><li>JavaScript<ul><li><input disabled="" type="checkbox"> 理解 JavaScript 中的执行上下文和执行栈</li><li><input disabled="" type="checkbox"> <a href="https://juejin.cn/post/6844904016212672519">你不知道的JSON.stringify的威力</a></li></ul></li><li>node<ul><li><input disabled="" type="checkbox"> 一篇文章构建你的 NodeJS 知识体系</li></ul></li><li>http<ul><li><input disabled="" type="checkbox"> 看图学HTTPS</li></ul></li><li>浏览器<ul><li><input disabled="" type="checkbox"> 前端必须要懂的浏览器缓存机制</li></ul></li><li>数据结构和算法<ul><li><input disabled="" type="checkbox"> 前端笔试&amp;面试爬坑系列—算法</li></ul></li><li>其他<ul><li><input disabled="" type="checkbox"> web 项目如何进行 git 多人协作开发</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>react Hooks</title>
      <link href="2020/01/01/Code-Frontend-react-Hooks/"/>
      <url>2020/01/01/Code-Frontend-react-Hooks/</url>
      
        <content type="html"><![CDATA[<p>Hooks API 的使用简单介绍</p><a id="more"></a><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><ul><li><code>useState</code></li><li><code>useEffect</code></li><li><code>useLayoutEffect</code></li><li><code>useCallBack</code></li><li><code>useMemo</code></li><li><code>useReducer</code></li><li><code>useRef</code></li><li><code>useContext</code></li><li><code>useImperativeHandle</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 更新文档的标题</span></span><br><span class="line">            <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>useState</code>:声明和改变组件状态。返回值是一个包含state和改变该state的函数的数组</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>参数： 函数接收的参数是一个初始值，初始值的类型不限，可以是<code>array</code>,<code>object</code>…</p></li><li><p>返回： 函数返回一个长度为2的数组，</p><ul><li><p>第一个值<code>useState(0)[0]</code>是组件的初始state，在这里即是<code>0</code></p><blockquote><p>react 会在每次组件渲染后保存这个状态，也就是说<code>useState</code>每次只会在组件首次渲染时执行(组件卸载后再加载初始赋值)</p></blockquote></li><li><p>第二个值<code>useState(0)[1]</code>是改变状态state的方法</p><ul><li><p><code>setCount</code>是改变组件状态的方法</p><ul><li><p>参数：接收的参数即是改变后的<code>状态</code>，接收后react会直接覆盖上一次的state</p><ul><li><p><code>function</code>参数：当传入<code>useState(0)[0]</code>的参数是一个函数，<strong>这个函数可以接收一个<code>previousState</code></strong>,返回值作为新的<code>state</code>值</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(&#123;<span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;)</span><br><span class="line">  <span class="keyword">let</span> [number, setNumber] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function">(<span class="params">preState</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="comment">// 要达到合并更新的效果，则需要使用...展开运算</span></span><br><span class="line">              ...preState,</span><br><span class="line">              age: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          cleanup</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;, [input]);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// setNumber(number + 1) // number 永远是1</span></span><br><span class="line">setNumber(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123; <span class="comment">// 使用函数更新可以解决number不变的问题</span></span><br><span class="line">        <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>useState和class 的setState 不同，不会自动合并更新，需要手动合并</p></blockquote></li></ul></li><li><p>返回：viod</p></li></ul></li></ul></li><li><p>可以多次使用<code>useState</code></p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [fruit, setFruit] =  useState(<span class="string">&#x27;banana)</span></span><br><span class="line"><span class="string">    const [todos, setTodo] = useState([&#123;text: &#x27;</span><span class="keyword">do</span> someting<span class="string">&#x27;&#125;])</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>useEffect</code> 副作用钩子</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似于componentDidMount 和 componentDidUpdate:</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 更新文档的标题</span></span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>useEffect</code>副作用钩子会在每次组件更新之后执行（包括第一次）</p></li><li><p><code>useEffect</code>中解绑一些副作用（如事件监听）：<code>useEffect</code>通过返回一个函数来解绑副作用</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        <span class="comment">// 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Loading...&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>useEffect</code> 中的解绑会在每次组件更新/卸载后，在<code>useEffect</code>中的操作执行前执行，组件卸载只会执行副作用的解绑函数，可以做一些事件的取消监听</p></blockquote></li></ul></li></ul><blockquote><p><code>useEffect</code> 是一个异步的函数，不会阻塞页面更新</p></blockquote><blockquote><p><code>useLayoutEffect</code> 是一个<code>useEffect</code>的同步版本函数，其使用方法和<code>useEffect</code>一样</p></blockquote><blockquote><p>和 <code>useLayoutEffect</code> 区别：<br>    <code>useEffect</code>执行顺序：组件更新挂载完成 -&gt; 浏览器渲染dom完成 -&gt; useEffect<br>    <code>useLayoutEffect</code>执行顺序：组件更新挂载完成 -&gt; useLayoutEffect -&gt; 浏览器渲染dom。所以虽然useLayoutEffect可以获取到最新的渲染数据，但是此时dom并没有渲染，如果处理量大可能阻碍浏览器渲染</p></blockquote><pre><code>- 跳过一些不必要的副作用    通过给 `useEffect`传入第二个参数，当第二个参数改变时才执行副作用    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 只有当count的值发生变化时，才会重新执行`document.title`这一句</span></span><br></pre></td></tr></table></figure>&gt; `useEffect`在每次执行前，会清除上一次的`useEffect`，以防止内存泄漏</code></pre><ul><li><p><code>useCallBack</code>：<code>useCallBack</code>用于生成一个回调函数，一般用于重复代码抽离</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> calcCount = useCallBack(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count+count2</span><br><span class="line">    &#125;,[count, count2])</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = calcCount()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sum---&#x27;</span>, sum)</span><br><span class="line">    &#125;,[calcCount])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;div className=&#123;<span class="string">&#x27;box&#x27;</span>&#125;&gt;</span><br><span class="line">        &#123;count&#125;&#123;count2&#125;&lt;Button onClick=&#123;setCount(count + <span class="number">1</span>)&#125;&gt;-&lt;<span class="regexp">/Button&gt;&lt;Button onClick=&#123;setCount2(count2+1)&#125;&gt;+&lt;/</span>Button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>useCallBack</code>的使用和<code>useEffect</code>相同，不过useCallBack生成一个回调函数。在第二个参数（数组）中的任一值改变时，会重新生成一个回调函数，在<code>useEffect</code>中的第二个参数监听这个生成的回调函数即可做进一步的操作</p></li><li><p><code>useMemo</code>： 接收两个参数，计算函数和函数所依赖的数据数组，返回一个由计算函数返回的‘memorized’值。<code>useMemo</code>用于“缓存”计算函数返回的值（可以是数据或者是组件），当所依赖的数据改变时，才会重新调用计算函数返回新的值。</p><blockquote><p><code>useMemo</code>的出现主要是为了性能优化。在函数组件中，当状态放生变化时，函数组件中所有通过计算出来的值/引入的组件和没有设置关联的effect中的副作用都会重新计算/挂载，当一个组件不用频繁更新并且开销很大时，就会造成性能浪费。</p></blockquote><blockquote><p><code>useMemo</code>的作用范畴类似<code>useEffect</code>，但是，<code>useMemo</code>中的计算都与渲染有关，而<code>useEffect</code>中都计算则是各种副作用，在hooks的使用上要各司其职</p></blockquote>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种写法下，每次改变count2也会输出count2的值</span></span><br><span class="line">    <span class="comment">// const count_ = (()=&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&#x27;count_&#x27;, count2)</span></span><br><span class="line">    <span class="comment">//   return count*2</span></span><br><span class="line">    <span class="comment">// &#125;)()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种写法下，只有当count改变，才会输出count2的值，当计算开销很大时，可以提高性能</span></span><br><span class="line">    <span class="keyword">const</span> count_ = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;count_2&#x27;</span>, count2)</span><br><span class="line">        <span class="keyword">return</span> count*<span class="number">2</span></span><br><span class="line">    &#125;,[count])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &#123;count_&#125;-&#123;count&#125;-&#123;count2&#125;-&#123;props.count&#125;</span><br><span class="line">        &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;double+&lt;/Button&gt;</span><br><span class="line">        &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount2(count2 + <span class="number">1</span>)&#125;&#125;&gt;+&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Memo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次都更新</span></span><br><span class="line">    <span class="comment">// const child = (() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&#x27;生成child&#x27;)</span></span><br><span class="line">    <span class="comment">//   return &lt;Demo count=&#123;count&#125; /&gt;</span></span><br><span class="line">    <span class="comment">// &#125;)()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> child = useMemo(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;生成child&#x27;</span>);<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;/</span>&gt;</span></span>&#125;, [count])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &#123;child&#125;...&#123;count2&#125;</span><br><span class="line">        &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount(count +<span class="number">1</span> )&#125;&#125;&gt;修改child&lt;/Button&gt;</span><br><span class="line">        &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount2(count2 + <span class="number">1</span>)&#125;&#125;&gt;修改count2&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>useReducer</code>: <code>useState</code>的替代方案，当组件中的<code>state</code>较多时，可以使用<code>useReducer</code>作为替代。钩子函数接受一个 <code>reducer</code>、一个初始的state<code>initialState</code>和一个处理初始state的处理函数<code>initState</code>，返回值是当前的state和配套的dispatch函数。用法十分类似<code>redux</code>。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始state</span></span><br><span class="line"><span class="keyword">const</span> initialCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理初始state的函数，可以把state初始化的一些操作放在函数内部</span></span><br><span class="line"><span class="keyword">const</span> initState = <span class="function">(<span class="params">initialCount</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略模式actions</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    add: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    subtract: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer函数，类似redux的reducer，接受state，和action，返回一个新的state</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, payload&#125; = action</span><br><span class="line">    <span class="keyword">const</span> act = actions[type]</span><br><span class="line"><span class="keyword">const</span> newState = act&amp;&amp;act(state, payload) || state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, initState)</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">            payload: <span class="string">&#x27;add action&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subtract = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;subtract&#x27;</span>,</span><br><span class="line">            payload: <span class="string">&#x27;subtract action&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;state.count&#125; <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>++<span class="tag">&lt;/<span class="name">Button</span>&gt;</span><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;subtract&#125;</span>&gt;</span>--<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>useRef</code>：生成一个可变的ref对象，对象中的<code>.current</code>被初始化为传入初始的值，ref对象在整个组件的生命周期中不会自动改变，基于此，ref对象一个强大的作用在于它能够保存某次state, 用于某些操作.</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState(<span class="string">&#x27;notChange&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> ref = useRef(<span class="literal">null</span>) <span class="comment">// &#123;current: null&#125;</span></span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;current&#125; = ref</span><br><span class="line">        <span class="keyword">if</span>(current) &#123;</span><br><span class="line">            setText(<span class="string">&#x27;currentChanged&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,[ref]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ref.current) &#123; <span class="comment">// 这里在未改变ref之前，count不会改变</span></span><br><span class="line">            setCount(count+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &#123;text&#125;&#123;count&#125;&lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;ref.current = <span class="literal">true</span>&#125;&#125; &gt;改变ref&lt;<span class="regexp">/Button&gt;&lt;Button onClick=&#123;add&#125;&gt;+&lt;/</span>Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当<code>useRef</code>用于组件或者DOM时，<code>ref.current</code>初始值会被赋予此组件或DOM元素。</p></blockquote><blockquote><p>改变<code>useRef</code>的值不会引起视图更新</p></blockquote><blockquote><p><code>useRef</code>创建的ref对象是不可扩展的</p></blockquote></li><li><p><code>useContext</code></p><p>接收一个context对象（<code>React.createContext</code> 的返回值）并返回该context当前值。</p><p>context的值由上层组件中距离当前组件最近的<code>&lt;MyContext.Provider&gt;</code> 的value属性提供</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(&#123;<span class="attr">name</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useContext(MyContext)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#123;<span class="comment">/*value2*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [currentValue, setCurrentValue] = useState(&#123;<span class="attr">name</span>: <span class="string">&#x27;value2&#x27;</span>&#125;)</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &lt;MyContext.Provider value=&#123;currentValue&#125;&gt;</span><br><span class="line">  &lt;MyComponent /&gt;</span><br><span class="line">    &lt;MyContext.Provider &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>useImperativeHandle(ref, createHandle, [deps])</code>，<code>ref</code>为父组件通过<code>forwardRef</code>传进来的ref，<code>createHandle</code> 函数返回的对象及为ref上挂载的对象，<code>deps</code>依赖更新生成新的ref</p><p>使用<code>useImperativeHandle</code>自定义暴露接口给父组件，需要结合<code>forwardRef</code>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const Son &#x3D; React.forwardRef((props, ref) &#x3D;&gt; &#123;</span><br><span class="line">  const [number, setNumber] &#x3D; useState(0)</span><br><span class="line">  const increase &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setNumber((number) &#x3D;&gt; number + 1)</span><br><span class="line">  &#125;</span><br><span class="line">  useImperativeHandle(ref, () &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      increase</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return &lt;div&gt;&#123;number&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function Father() &#123;</span><br><span class="line">const ref &#x3D; useRef(null)</span><br><span class="line">  const handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    ref.current.increase() &#x2F;&#x2F; 调用子组件暴露的方法</span><br><span class="line">  &#125;</span><br><span class="line">return &lt;div&gt;</span><br><span class="line">  &lt;Son ref&#x3D;&#123;ref&#125;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>Hooks 使用的一些规则<ol><li>只在函数组件的最上层使用 <code>Hooks</code>,不得在循环、判断、函数中使用Hooks,让多次调用的<code>useState``useEffect</code>有一个确定的顺序<ol start="2"><li> 只在函数组件中使用<code>Hooks</code></li></ol></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router</title>
      <link href="2020/01/01/Code-Frontend-react-react-route/"/>
      <url>2020/01/01/Code-Frontend-react-react-route/</url>
      
        <content type="html"><![CDATA[<p>react-router介绍</p><a id="more"></a><h4 id="react-路由"><a href="#react-路由" class="headerlink" title="react 路由"></a>react 路由</h4><hr><p>react-router的使用</p><ul><li><p>react-router、react-router-dom、react-router-native的区别</p><ul><li>react-router是路由的核心，react-router-dom 比前者多出了 <code>&lt;link&gt;</code>，<code>&lt;BrowserRouter&gt;</code> 这样的 DOM 类组件</li><li>如果你在开发一个网站，你应该使用<code>react-router-dom</code>，如果你在移动应用的开发环境使用React Native，你应该使用<code>react-router-native</code></li><li>我们这里使用 react-router-dom 即可</li></ul></li><li><p><code>react-router</code>（react-router-dom）的使用</p><ul><li><p>基本的路由结构为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;<span class="comment">// 或者 HashRouter</span></span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>因此，我们首先需要在 SPA 应用最外层包裹上一个 Router，Router 分为两种：BrowserRouter 和 HashRouter</p><ul><li>BrowserRouter:<br>使用了HTML5的history API来记录你的路由历史使用了HTML5的history API来记录你的路由历史</li><li>HashRouter:<br>使用URL<code>(window.location.hash)</code>的hash部分来记录</li></ul></li><li><p>在需要切换路由的时候，使用 <code>&lt;Route&gt;</code> 来作为匹配路由选择</p><ul><li>Route 的一些参数：<ul><li>path：string 路径</li><li>component:componentcomponent 渲染的组件。当访问地址和路由匹配时，对应的 component 将会被渲染，并且传入 match、location、history</li><li>render：func render 函数返回需要渲染的组件</li><li>exact：boolean 为 true 时路径将会精准匹配，’/one’ 的路由将不能匹配 ‘/one/two’</li><li>strict：boolean 对路径末尾斜杠的匹配，为 true 时 ‘/one/‘ 将不能匹配 ‘/one’ 但可以匹配 ‘/one/two’，需要确保路由没有末尾斜杠，那么需要 exact 和 strict 都为 true<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router exact=&#123; <span class="literal">true</span> &#125; path=<span class="string">&quot;/home&quot;</span> component= &#123; AppHome &#125; /&gt; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>&lt;Switch&gt;</code><br>  Switch 只会渲染第一个与当前访问地址匹配的 Router 或者 redirect，有效防止同级路由多次渲染</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/&quot;</span> component= &#123; AppHome &#125; /&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/mine&quot;</span> component= &#123; AppMine &#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"><span class="comment">// 当路径为&#x27;/&#x27;时，只渲染第一个</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;Redirect&gt;</code>：重定向。可以使用 Redirect 组件，添加 from 、to 属性进行重定向跳转</p></li><li><p><code>&lt;Link&gt;</code> 和 <code>&lt;NavLink&gt;</code>：</p><ul><li><code>&lt;Link&gt;</code>：声明式导航<ul><li>to：string 跳转指定路径</li><li>to: Object 带参数跳转到指定路径<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">&#x27;/course&#x27;</span>,</span><br><span class="line">  state: &#123; <span class="attr">price</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure></li><li>replace: boolean 跳转时，是否替换访问历史</li></ul></li><li><code>&lt;NavLink&gt;</code>: <code>&lt;Link&gt;</code> 的特殊版，增加了：<ul><li>activeClassName: String 激活时的类名</li><li>activeStyle: Object 激活时的内联样式</li><li>exact：boolean 是否精准匹配</li><li>strict：bolean 是否匹配最后的斜杠</li><li>isActive：func 激活时执行函数</li></ul></li></ul></li><li><p><code>history</code> 对象通常具有以下属性和方法：</p><ul><li>length: number 浏览历史堆栈中的条目数</li><li>action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP</li><li>location: object 当前访问地址信息组成的对象，具有如下属性：<ul><li><code>pathname</code>: string URL路径</li><li>search: string URL中的查询字符串</li><li>hash: string URL的 hash 片段</li><li>state: string 例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state 只有在 browser 和 memory history 有效。</li><li><code>push(path, [state])</code> 在历史堆栈信息里加入一个新条目。</li><li><code>replace(path, [state])</code> 在历史堆栈信息里替换掉当前的条目</li><li><code>go(n)</code> 将 history 堆栈中的指针向前移动 n。</li><li>goBack() 等同于 go(-1)</li><li>goForward 等同于 go(1)</li><li>block(prompt) 阻止跳转</li></ul></li></ul></li><li><p><code>location</code>:当前的位置，将要去的位置，或是之前所在的位置<br>在以下情境中可以获取 location 对象</p><ul><li>在 Route component 中，以 <code>this.props.location</code> 获取</li><li>在 Route render 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 Route children 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 withRouter 中，以 <code>this.props.location</code> 的方式获取</li></ul></li><li><p>路由传参：</p></li><li><p><code>&lt;withRouter&gt;</code> 根据传入的组件生成一个新的组件（高阶组件），<code>&lt;withRouter&gt;</code> 处理过的组件外面会有 Router ，可以使用 <code>this.props.history</code> 等的属性</p></li><li><p>路由钩子：<br>react-router 没有路由钩子，我们需要根据组件的声明周期做出相应的处理<br>比如，当我们要监听某一个组件的进入和离开，我们利用<code>componentWillMount</code>、<code>componentWillUnmount</code><br>全局路由切换, 我们觉得在App里监听就可以了，因为当路由切换的时候，父级路由组件的location属性中pathname会变化<br>但是App组件虽然是全部路由组件的父级组件，但是它不是一个路由组件，所以App外面没有Route组件，所以App没有location属性，所以，无法坚持属性的变化<br>我们可以李扬withRouter来将App处理一下，就是在他外面包一个Route来实现这一个功能<br>我们发现withRouter他可以在任意组件外面包上Route，也就是说，可以让非路由组件也能使用到路由相关的属性</p></li></ul></li></ul><ul><li><p>react-router 的原生数组对象写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routeConfig = [</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    component: App,</span><br><span class="line">    indexRoute: &#123; <span class="attr">component</span>: Dashboard &#125;,</span><br><span class="line">    childRoutes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: About &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;inbox&#x27;</span>,</span><br><span class="line">        component: Inbox,</span><br><span class="line">        childRoutes: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/messages/:id&#x27;</span>, <span class="attr">component</span>: Message &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;messages/:id&#x27;</span>,</span><br><span class="line">            onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">nextState, replaceState</span>) </span>&#123;</span><br><span class="line">            replaceState(<span class="literal">null</span>, <span class="string">&#x27;/messages/&#x27;</span> + nextState.params.id)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">React.render(<span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">routes</span>=<span class="string">&#123;routeConfig&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure></li><li><p>复合式写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &#123;&#123;</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      component: App,</span><br><span class="line">      childRoutes: []</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  &#123;&#123;</span><br><span class="line">    path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getComponent</span>(<span class="params">nextState, callback</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">require</span>.ensure([], <span class="function"><span class="params">require</span> =&gt;</span> &#123;</span><br><span class="line">        callback(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">&#x27;src/login&#x27;</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="comment">// component 的按需加载式写法</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><ul><li><code>require-ensure</code><ul><li>说明: <code>require.ensure</code>在需要的时候才下载依赖的模块，当参数指定的模块都下载下来了（下载下来的模块还没执行），便执行参数指定的回调函数。<code>require.ensure</code>会创建一个chunk，且可以指定该chunk的名称，如果这个chunk名已经存在了，则将本次依赖的模块合并到已经存在的chunk中，最后这个chunk在webpack构建的时候会单独生成一个文件。</li><li>语法:<code>require.ensure(dependencies: String[], callback: function([require]), [chunkName: String])</code><ul><li><code>dependencies</code>: 依赖的模块数组</li><li><code>callback</code>: 回调函数，该函数调用时会传一个require参数</li><li><code>chunkName</code>: 模块名，用于构建时生成文件时命名使用</li></ul></li><li>注意点：<code>requi.ensure</code>的模块只会被下载下来，不会被执行，只有在回调函数使用<code>require(模块名)</code>后，这个模块才会被执行。</li></ul></li></ul></li><li><p>路由的按需加载</p><ul><li>定义加载组件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncComponent</span>(<span class="params">importComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        component: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> importComponent();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        component: component</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> C = <span class="built_in">this</span>.state.component;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> C ? <span class="xml"><span class="tag">&lt;<span class="name">C</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AsyncComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>路由表中使用加载组件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Buttons = asyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./button&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>babel 配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;es2015&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;stage-1&quot;</span>, <span class="comment">// 应用了es7的语法，所以必须有这个配置</span></span><br><span class="line">  <span class="string">&quot;react&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p><code>react-router</code>相关梳理</p><ul><li><p>什么是<code>react-router-dom</code>、<code>react-router</code>、<code>react-router-native</code>？<br>总括来说，<code>react-router</code>是react管理路由的工具的总称，其中包括核心的<code>react-router</code>，专门为web端的dom绑定操作的<code>react-router-dom</code>， 专门为<code>react-native</code>使用的<code>react-router-native</code>，此外还有<code>react-router-config</code>和<code>react-router-redux</code>，在react-router的官方GitHub上可以看到起关系<br><img src="https://github.com/LintheGH/images/tree/master/note/react-router.png" alt="react-router"></p><p>在项目中</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 小tips</title>
      <link href="2020/01/01/Code-Frontend-react-tips/"/>
      <url>2020/01/01/Code-Frontend-react-tips/</url>
      
        <content type="html"><![CDATA[<p>react 小tips</p><a id="more"></a><h3 id="开发中发现的小技巧-注意事项"><a href="#开发中发现的小技巧-注意事项" class="headerlink" title="开发中发现的小技巧/注意事项"></a>开发中发现的小技巧/注意事项</h3><hr><ul><li><p><code>getDerivedStateFromProps</code> 钩子函数</p><p>  <code>getDerivedStateFromProps</code> 钩子函数存在时，不会执行 <code>componentWillMount</code> 钩子函数， 这个钩子函数在每次 <code>render</code> 执行前都会执行，因此通过<code>getDerivedStateFromProps</code>更新的state中的属性不会在接收属性的组件中通过自身的<code>setState</code>更新，state 中的属性值跟传递过来的属性值保持一致<br>  <code>getDerivedStateFromProps</code>函数接收参数<code>preProps``preState</code>，函数内部不能获取到组件实例本身，故无法获取<code>this</code></p></li><li><p><code>props</code>的传递</p><p>  当我们把父组件的数据传递到子组件时，通常子组件会<code>this.props.xxxx</code>接收</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>id is:&#123;this.props.data.attr.id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        sonData: &#123;</span><br><span class="line">            attr: &#123;</span><br><span class="line">                id: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">data</span>=<span class="string">&#123;this.state.sonData&#125;/</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这时<code>id</code>的值时同步传过来到，子组件在渲染时可以第一时间获取到传过来到值</p><p>  但是当传递当值时父组件通过异步获取到时，子组件在初次渲染时就会获取不到值，从而时页面崩溃<br>  这时需要加上判断</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>id is:&#123;!!this.props.data.attr?this.props.data.attr.id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        sonData: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                sonData: &#123;</span><br><span class="line">                    attr: &#123;</span><br><span class="line">                        id: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                        name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">data</span>=<span class="string">&#123;this.state.sonData&#125;/</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在一些需要用到父组件数据来是请求数据时，可以在<code>componentUpdate</code>、<code>componentWillReceiveProps</code>(将被删除，不推荐)、<code>getDerivedStateFromProps</code>钩子函数中判断数据是否存在来做进一步操作</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">preProps, preState</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!!<span class="built_in">this</span>.props.attr.id) &#123;</span><br><span class="line">            axios.get(...).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    age: res.data.age</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;age&#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">            &#123;age&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>key</code>：react中的key是组件的身份标识，每个key对应一个组件，相同key的组件被认为是同一个组件，后续组件不会被创建，如下</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this.state.users内容</span></span><br><span class="line"><span class="built_in">this</span>.state = &#123;</span><br><span class="line">    users: [&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>&#125;],</span><br><span class="line">    ....<span class="comment">//省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;用户列表&lt;/h3&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.users.map(<span class="function"><span class="params">u</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;u.id&#125;</span>&gt;</span>&#123;u.id&#125;:&#123;u.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述组件中的渲染后，用户列表只有<code>章三</code>和<code>李四</code>两个用户，李四和王五的可以相同，被认为是同一个组件</p><p>  react对拥有key属性的组件的处理</p><ul><li><strong>key相同</strong>： 若组件属性有变化，react只更新组件对应的属性，没有变化则不更新</li><li><strong>key不相同</strong>：组件销毁，然后再重新创建一个组件，此时组件的生命周期会重新执行</li></ul></li><li><p>antd 的表单提交的问题</p><p>  antd中的form 表单提交，当按钮用htmlType=”submit” 时，提交的函数必须调用 <code>e.preventDefault</code> 函数阻止默认行为</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react</title>
      <link href="2020/01/01/Code-Frontend-react-react/"/>
      <url>2020/01/01/Code-Frontend-react-react/</url>
      
        <content type="html"><![CDATA[<p>react 介绍</p><a id="more"></a><h1 id="react-轻量级视图层框架"><a href="#react-轻量级视图层框架" class="headerlink" title="react:轻量级视图层框架"></a>react:轻量级视图层框架</h1><h4 id="react-高性能的体现：虚拟-DOM"><a href="#react-高性能的体现：虚拟-DOM" class="headerlink" title="react 高性能的体现：虚拟 DOM"></a>react 高性能的体现：虚拟 DOM</h4><p>  React高性能的原理：</p><p>在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。</p><p>React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A  UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。</p><p>尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，部而对实际DOM进行操作的仅仅是Diff分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。数据驱动，声明式</p><h4 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h4><ul><li><p>虚拟DOM</p><p>我们以前操作dom的方式是通过document.getElementById()的方式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进行操作</p><p>而reactjs定义了一套变量形式的dom模型，一切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的高，和主流MVC框架有本质的区别，并不和dom打交道</p></li><li><p>组件系统</p><p>react最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件 component</p><p>那么什么是组件呢？</p><p>组件指的就是同时包含了html、css、js、image元素的聚合体</p><p>使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式</p></li><li><p>单向数据流</p><p>其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了</p></li><li><p>语法</p><p>在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; React.createElement 函数创建 DOM 结构</span><br><span class="line">React.createElement(&#39;div&#39;, null,</span><br><span class="line">  React.createElement(&#39;h1&#39;, null, &#39;Hello World&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="依赖文件"><a href="#依赖文件" class="headerlink" title="依赖文件"></a>依赖文件</h4></li><li><p>react.js<br>React 对象，有创建组件等功能</p></li><li><p>react-dom<br>ReactDOM 对象，渲染组件的虚拟 DOM 为真实 DOM 的爆发功能</p></li><li><p>编译 JSX 代码</p><ul><li>浏览器端编译，需要引入 browser 文件</li><li>利用 webpack 等开发环境编译</li></ul></li></ul><h4 id="JSX-（javascript-xml）"><a href="#JSX-（javascript-xml）" class="headerlink" title="JSX （javascript xml）"></a>JSX （javascript xml）</h4><p>JSX 借鉴了 xml 的语法，但是因为是 javascript 语法，所以应遵循 js 语法规则（关键字等）</p><h4 id="react-组件"><a href="#react-组件" class="headerlink" title="react 组件"></a>react 组件</h4><ul><li>在react里表达式的符号是 “{  }”,作用和vue的表达式作用是一样的</li><li>为组件添加类名，class需要写成className（因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字）</li><li>为组件绑定事件：事件名字需要写成小驼峰的方式，值利用表达式传入一个函数即可 </li><li>defaultValue</li><li>defaultChecked</li><li>dangerouslySetInnerHtml<br>让标签编译 html 代码，容易受到 XSS 攻击<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function handleClick ()&#123;operation&#125;</span><br><span class="line">render () &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D; &#123;this.handleClick&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建组件 组件渲染到 APP 节点时会覆盖里面的内容</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;aaa&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;&#x2F;&#x2F; 设定为 babel 让 browser 编译</span><br><span class="line">  var Hello &#x3D; React.createClass(&#123;&#x2F;&#x2F; 组件名开头必须大写</span><br><span class="line">    render () &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">          &#123;&#x2F;* JSX 里面的注释必须写成这种格式，否则会被编译*&#x2F;&#125;</span><br><span class="line">            &lt;h1&gt;Hello World&lt;&#x2F;h1&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; ReactDOM.render 函数渲染 DOM 的到页面</span><br><span class="line">  ReactDOM.render(&lt;Hello&gt;&lt;&#x2F;Hello&gt;,app)</span><br></pre></td></tr></table></figure></li><li>ref 为组件标记<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p ref = <span class="string">&quot;p&quot;</span>&gt; Hello World &lt;/p&gt;</span><br><span class="line">        &lt;p ref = &#123; <span class="function">(<span class="params">el</span>) =&gt;</span> &#123; <span class="built_in">this</span>.pp = el &#125; &#125;&gt; Hello World &lt;<span class="regexp">/p&gt; /</span><span class="regexp">/ ref 内的函数接收到当前标记的 NODE 返回 this.pp = el，即把当前 NODE 挂载到组件中</span></span><br><span class="line"><span class="regexp">        &lt;button onClick = &#123;this.changeWorldColor&#125;&gt; change &lt;/</span>button&gt;</span><br><span class="line">        &lt;World ref = &#123;<span class="function"><span class="params">world</span> =&gt;</span> <span class="built_in">this</span>.world = world&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount () &#123; <span class="comment">//ref的标记官方推荐使用函数的方式，接收到要做标记的元素或者子组件，将其挂载this上</span></span><br><span class="line">    <span class="built_in">this</span>.refs.p.style.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.pp.style.color = <span class="string">&#x27;pink&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>map<ul><li>在react中使用map方法来将数据数组转换成盛放虚拟dom结构的数组，利用表达式放入到组件的虚拟dom结构中，在 <code>&#123;&#125;</code> 内的数组会被动态解析<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</span><br><span class="line">  getInitailState () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      fruit: [</span><br><span class="line">        <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;watermelon&#x27;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  renderFruit () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.fruit.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span> = <span class="string">i</span>&gt;</span> &#123; item &#125; ))// 可以根据需要循环出需要的数据</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  render () &#123;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123; this.renderFruit() &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">Hello</span>/&gt;</span>, app)</span></span><br></pre></td></tr></table></figure><h4 id="Props-和-State"><a href="#Props-和-State" class="headerlink" title="Props 和 State"></a>Props 和 State</h4></li></ul></li><li>属性（Props）：在组件外部传入，或者内部设置（getDefaultProps），组件内通过 <code>this.props</code>获取</li><li>状态（state）：由组件设置或更改，内部通过 <code>this.state</code>获取</li><li>getDefaultPorps()</li><li>getInitialState</li><li>setState<br>更改组件的状态 state 会触发重新渲染<br>在setState中传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须返回像上面方式一样的一个对象，函数可以接收prevState和props<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> Father = React.createClass(&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;我是父组件&lt;/p&gt;</span><br><span class="line">          &lt;Son name=&#123;<span class="string">&#x27;tom&#x27;</span>&#125;&gt;&lt;/Son&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">var</span> Son = React.createClass(&#123;</span><br><span class="line">    getDefaultProps () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;jim&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getInitialState () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    changeAge () &#123;</span><br><span class="line">      <span class="comment">// this.state.age++ // 不会触发视图更新</span></span><br><span class="line">      <span class="comment">// this.setState ((previousState, props) =&gt; &#123; // 触发视图更新</span></span><br><span class="line">      <span class="comment">//   return &#123;</span></span><br><span class="line">      <span class="comment">//     age: previousState.age + 1</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        age: <span class="built_in">this</span>.state.age+<span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;我是子组件&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;我的名字是：&#123;<span class="built_in">this</span>.props.name&#125;, 年龄：&#123; <span class="built_in">this</span>.state.age &#125;&lt;<span class="regexp">/p&gt;&#123;/</span>*父组件传入会覆盖初始属性*/&#125;</span><br><span class="line">          &lt;button onClick= &#123; <span class="built_in">this</span>.changeAge &#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Father</span>/&gt;</span></span>,app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="属性和状态的对比"><a href="#属性和状态的对比" class="headerlink" title="属性和状态的对比"></a>属性和状态的对比</h4></li></ul><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点： </p><ol><li>属性能从父组件获取，状态不能</li><li>属性可以由父组件修改，状态不能</li><li>属性能在内部设置默认值 ，状态也可以</li><li>属性不在组件内部修改   ，状态要改</li><li>属性能设置子组件初始值  ，状态不可以</li><li>属性可以修改子组件的值，状态不可以</li></ol><p>状态只和自己相关，由自己维护</p><p>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p><h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p><img src="https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg" alt="life cycle"></p><ul><li>初始化阶段钩子函数<ul><li>getDefaultPorps () <ul><li>作用：挂载默认属性，当给组件设置属性的时候会覆盖掉（优先级低）</li><li>特点： <ul><li>不管实例化多少次组件，只执行一次，因为组件实例间的默认属性是共享的</li></ul></li></ul></li><li>getInitailState () {}<ul><li>每次实例化组件都会执行，也就是说每一个组件都有一个自己独立的状态</li></ul></li><li>componentWillMount () {}<ul><li>相当与 vue 的 created + beforeMount ，渲染之前最后一次更改数据的机会，更改数据不会触发 render 的重新执行<blockquote><p>react中官方不推荐我们在componentWillMount里这么做，会有安全的问题</p></blockquote></li></ul></li><li>render () {}<ul><li>渲染 DOM </li></ul></li><li>componentDidMount () {}<ul><li>页面中生成真实的 DOM ，可以做 DOM 相关的操作</li></ul></li></ul></li><li>组件运行阶段钩子函数<ul><li>componentWillReceiveProps (nextProps) {}<ul><li>这时得知属性的变化，执行对应操作</li><li>形参 nextProps 是新的数据，而 this.props 和 this.state 仍然为更改前的数据</li></ul></li><li>shouldComponentUpdate (nextProps, nextState) {}<ul><li>componentWillReceiveProps 钩子后执行</li><li>函数返回值为 true 时，组件才更新，false 时不会更新，当代码中书写了这个函数时，默认会返回 false </li><li>接收新的数据 nextProp nextState ，可以根据新数据和原数据对比，控制组件是否更新</li></ul></li><li>componentWillUpdate(nextProps, nextState)<ul><li>组件马上更新，在函数内不要更新状态，否则<strong>死循环</strong></li></ul></li><li>render () {}<ul><li>组件重新渲染</li></ul></li><li>componentDidUpdate (preProps, preState) {}<ul><li>更改完成，页面重新生成 DOM </li></ul></li></ul></li><li>组件销毁阶段<ul><li>componentWillUnmount () {}<br>怎么样就算组件被销毁：<ol><li>当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁</li><li>调用ReactDOM.unmountComponentAtNode(node) 方法来将某节点中的组件销毁</li></ol></li></ul></li></ul><h5 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h5><p>  功能： 更改函数的this指向<br>  es6 -&gt; 全局函数中的this不指向window<br>  call和apply是在调用函数的过程中，将函数的this改掉<br>  bind 更改指针和传参的方式和call一样，但是不能执行函数，而是返回一个新的更改指针并传参后的函数</p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><ul><li><p>父子组件通信</p></li><li><p>非父子组件通信</p><ul><li>状态提升</li></ul></li></ul><h4 id="无状态组件（函数定义组件）"><a href="#无状态组件（函数定义组件）" class="headerlink" title="无状态组件（函数定义组件）"></a>无状态组件（函数定义组件）</h4><p>在使用组件的时候，我们不需要组件拥有自己的状态，只需要接收外界传入的属性之后做出反应（如渲染相应的 DOM 结构）<br>可以利用纯函数的方式将其制作成无状态组件，提高性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 定义无状态组件</span></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick = &#123; props.handler &#125;&gt;pay&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用无状态组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pay</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>= &#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.props = &#123;</span><br><span class="line">      handler () &#123;</span><br><span class="line">        alert(<span class="string">&#x27;const $110&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button props = &#123;<span class="built_in">this</span>.props&#125; /&gt; <span class="comment">// 传入 this.props</span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="context-传递数据"><a href="#context-传递数据" class="headerlink" title="context 传递数据"></a>context 传递数据</h4><p>组件间的数据传递默认是层层传递，不能跳层。<br>react 提供了context 组件树状态传递方式，可以把数据让某一个外层的父级组件创建一个 context ,然后利用 Context.Provider 传递给所有的子级组件，任意子级组件可以通过 Context.Consumer 来获取这个 context 上的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> </span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 创建一个 theme Context ，默认值为 light</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        &#123; <span class="function"><span class="keyword">function</span> (<span class="params">theme</span>) </span>&#123; <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123; theme &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125; &#125; <span class="comment">// 函数接收 dark 返回渲染出组件</span></span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;B/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    &lt;ThemeContext.Provider value=<span class="string">&quot;dark&quot;</span>&gt; <span class="comment">// 传入一个 dark</span></span><br><span class="line">      &lt;A/&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6-的react"><a href="#ES6-的react" class="headerlink" title="ES6 的react"></a>ES6 的react</h4><p>在新版的 react 中，采用了新的组件创建方式和新的属性、状态设置方式</p><ul><li>组件创建使用 class 来创建</li><li>在 es6 中不再使用 getInitialState 来设置默认属性，而是在 constructor 里直接给 this.state 上挂载数据</li><li>属性设置通过给类设置 defaultProps 属性来设置默认属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span> <span class="title">component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      doing: <span class="string">&#x27;studing&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">App.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">&#x27;App根组件&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="react-路由"><a href="#react-路由" class="headerlink" title="react 路由"></a>react 路由</h4><hr><p>react-router的使用</p><ul><li><p>react-router、react-router-dom、react-router-native的区别</p><ul><li>react-router是路由的核心，react-router-dom 比前者多出了 <code>&lt;link&gt;</code>，<code>&lt;BrowserRouter&gt;</code> 这样的 DOM 类组件</li><li>如果你在开发一个网站，你应该使用<code>react-router-dom</code>，如果你在移动应用的开发环境使用React Native，你应该使用<code>react-router-native</code></li><li>我们这里使用 react-router-dom 即可</li></ul></li><li><p><code>react-router</code>（react-router-dom）的使用</p><ul><li><p>基本的路由结构为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;<span class="comment">// 或者 HashRouter</span></span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>因此，我们首先需要在 SPA 应用最外层包裹上一个 Router，Router 分为两种：BrowserRouter 和 HashRouter</p><ul><li>BrowserRouter:<br>使用了HTML5的history API来记录你的路由历史使用了HTML5的history API来记录你的路由历史</li><li>HashRouter:<br>使用URL<code>(window.location.hash)</code>的hash部分来记录</li></ul></li><li><p>在需要切换路由的时候，使用 <code>&lt;Route&gt;</code> 来作为匹配路由选择</p><ul><li>Route 的一些参数：<ul><li>path：string 路径</li><li>component:componentcomponent 渲染的组件。当访问地址和路由匹配时，对应的 component 将会被渲染，并且传入 match、location、history</li><li>render：func render 函数返回需要渲染的组件</li><li>exact：boolean 为 true 时路径将会精准匹配，’/one’ 的路由将不能匹配 ‘/one/two’</li><li>strict：boolean 对路径末尾斜杠的匹配，为 true 时 ‘/one/‘ 将不能匹配 ‘/one’ 但可以匹配 ‘/one/two’，需要确保路由没有末尾斜杠，那么需要 exact 和 strict 都为 true<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router exact=&#123; <span class="literal">true</span> &#125; path=<span class="string">&quot;/home&quot;</span> component= &#123; AppHome &#125; /&gt; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>&lt;Switch&gt;</code><br>  Switch 只会渲染第一个与当前访问地址匹配的 Router 或者 redirect，有效防止同级路由多次渲染</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/&quot;</span> component= &#123; AppHome &#125; /&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/mine&quot;</span> component= &#123; AppMine &#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"><span class="comment">// 当路径为&#x27;/&#x27;时，只渲染第一个</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;Redirect&gt;</code>：重定向。可以使用 Redirect 组件，添加 from 、to 属性进行重定向跳转</p></li><li><p><code>&lt;Link&gt;</code> 和 <code>&lt;NavLink&gt;</code>：</p><ul><li><code>&lt;Link&gt;</code>：声明式导航<ul><li>to：string 跳转指定路径</li><li>to: Object 带参数跳转到指定路径<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123; </span><br><span class="line">  pathname: <span class="string">&#x27;/course&#x27;</span>,</span><br><span class="line">  state: &#123; <span class="attr">price</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure></li><li>replace: boolean 跳转时，是否替换访问历史</li></ul></li><li><code>&lt;NavLink&gt;</code>: <code>&lt;Link&gt;</code> 的特殊版，增加了：<ul><li>activeClassName: String 激活时的类名</li><li>activeStyle: Object 激活时的内联样式</li><li>exact：boolean 是否精准匹配</li><li>strict：bolean 是否匹配最后的斜杠</li><li>isActive：func 激活时执行函数</li></ul></li></ul></li><li><p><code>history</code> 对象通常具有以下属性和方法：</p><ul><li>length: number 浏览历史堆栈中的条目数</li><li>action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP</li><li>location: object 当前访问地址信息组成的对象，具有如下属性：<ul><li><code>pathname</code>: string URL路径</li><li>search: string URL中的查询字符串</li><li>hash: string URL的 hash 片段</li><li>state: string 例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state 只有在 browser 和 memory history 有效。</li><li><code>push(path, [state])</code> 在历史堆栈信息里加入一个新条目。</li><li><code>replace(path, [state])</code> 在历史堆栈信息里替换掉当前的条目</li><li><code>go(n)</code> 将 history 堆栈中的指针向前移动 n。</li><li>goBack() 等同于 go(-1)</li><li>goForward 等同于 go(1)</li><li>block(prompt) 阻止跳转</li></ul></li></ul></li><li><p><code>location</code>:当前的位置，将要去的位置，或是之前所在的位置<br>在以下情境中可以获取 location 对象</p><ul><li>在 Route component 中，以 <code>this.props.location</code> 获取</li><li>在 Route render 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 Route children 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 withRouter 中，以 <code>this.props.location</code> 的方式获取</li></ul></li><li><p>路由传参：</p></li><li><p><code>&lt;withRouter&gt;</code> 根据传入的组件生成一个新的组件（高阶组件），<code>&lt;withRouter&gt;</code> 处理过的组件外面会有 Router ，可以使用 <code>this.props.history</code> 等的属性</p></li><li><p>路由钩子：<br>react-router 没有路由钩子，我们需要根据组件的声明周期做出相应的处理<br>比如，当我们要监听某一个组件的进入和离开，我们利用<code>componentWillMount</code>、<code>componentWillUnmount</code><br>全局路由切换, 我们觉得在App里监听就可以了，因为当路由切换的时候，父级路由组件的location属性中pathname会变化<br>但是App组件虽然是全部路由组件的父级组件，但是它不是一个路由组件，所以App外面没有Route组件，所以App没有location属性，所以，无法坚持属性的变化<br>我们可以李扬withRouter来将App处理一下，就是在他外面包一个Route来实现这一个功能<br>我们发现withRouter他可以在任意组件外面包上Route，也就是说，可以让非路由组件也能使用到路由相关的属性</p></li></ul></li></ul><h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>hoc<br>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件</p><h4 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h4><p>在 vue 中可以利用空实例进行非父子之间通信，因为 vue 的实例拥有 <code>$on</code>, <code>$emit</code> 方法，可以绑定事件和触发事件，就可以在一个组件中为实例绑定事件，在另一个实例里为这个空实例触发事件<br>在 react 中，可以引入 node 中的 events 模块中 EventEmitter, 它的原型上有 <code>on</code>， <code>emit</code></p><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><hr><p>redux 是一个架构思想，redux 工具实现这种思想<br>redux 架构是应用系统架构，和 MVC、MVVM 同种概念</p><ul><li><p>redux 的结构： store、reducer、view、actionCreator</p></li><li><p>安装 redux 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux -S</span><br></pre></td></tr></table></figure></li><li><p><code>store</code>： </p><ul><li>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</li><li>创建 store<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)<span class="comment">// 注册时传入一个函数（reducer），在调用 store.dispatch(action) 的时候会自动调用函数（reducer）</span></span><br></pre></td></tr></table></figure>createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。</li></ul></li><li><p>reducer ：</p><ul><li>Store 收到 Action 以后，必须给出一个新的 State（在previousState 中如果存在 Array,Object 等的引用类型的时候需要重新赋予新的引用地址），这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</li><li>reducer 是一个纯函数，接收两个函数：当前的状态（state）、以及action，返回一个新的状态就代表这store中的 state 改变了</li><li>给 reducer 函数中参数 <code>previousState</code> 设置默认值则为 state 设置了默认值<blockquote><p>当 createStore 中传入第二个参数时，表示 state 的最初状态，这个状态会覆盖 reducer 设置的默认 state</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span> <span class="comment">// 设置的默认值</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">previousState = state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> new_state = &#123; ...previousState &#125;</span><br><span class="line">  <span class="keyword">return</span> new_state</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer <span class="comment">// 暴露出去给 createStore </span></span><br></pre></td></tr></table></figure><blockquote><p>纯函数：只要是同样的输入就会得到同样的输出</p><ul><li>不得改写参数</li><li>不能调用系统 I/O 的 API </li><li>不能调用 <code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会输出不确定的结果</li></ul></blockquote></li></ul></li><li><p>使用 store 中的状态</p><p><code>store.getState()</code> 方法可以获得其中管理的 state</p><blockquote><p>state: Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。</p></blockquote></li><li><p>action</p><ul><li>当 view 需要更改状态的时候，创建 action 来生成来生成一个动作</li><li>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。其他属性可以自由设置</li><li>actionCreator： View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actionCreator = &#123;<span class="comment">// 组件调用 actionCreator 选择需要的函数</span></span><br><span class="line">  login (username) &#123;<span class="comment">// 返回一个 action（对象）</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">&#x27;CHANGE_USERINFO&#x27;</span>,</span><br><span class="line">      username</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>store.dispatch()</code> 方法</p><ul><li><code>store.dispatch()</code>是 View 发出 Action 的唯一方法。</li><li><code>store.dispatch()</code> 会自动调用 reducer 生成一个新的 state</li></ul></li><li><p><code>store.subscribe()</code></p><ul><li>组件中想要得知状态改变的化，则需要使用 <code>store.subscribe()</code> 方法来订阅状态变化，传入回调函数，这个函数会在状态变化时执行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState()) <span class="comment">// 当 state 改变时就会输出 state</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。<blockquote><p>只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入listen，就会实现 View 的自动渲染</p></blockquote></li></ul></li><li><p>reducer 划分<br>在 vuex 中可以分模块管理模块，可以更好的协同合作，互不干扰，在 redux 中划分模块，划分 reducer 即可</p><ul><li>reducer 使用 redux 提供的 <code>combineReducers</code> 来划分 reducer<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todolist <span class="keyword">from</span> <span class="string">&#x27;./todolist&#x27;</span></span><br><span class="line"><span class="keyword">import</span> couter <span class="keyword">from</span> <span class="string">&#x27;./couter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todolist,</span><br><span class="line">  couter</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取用 state</span></span><br><span class="line">store.getState().todolist.aaa</span><br><span class="line">store.getState().couter.bbb</span><br></pre></td></tr></table></figure></li></ul></li><li><p>redux 执行流程<br><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt="redux"></p></li></ul><ol><li>用户发出 action  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(action)</span><br></pre></td></tr></table></figure></li><li>store 自动调用 reducer ，接收两个参数，当前 state 和 action，返回一个新的 state <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextState = reducer(previousState, action)</span><br></pre></td></tr></table></figure></li><li>state 变化，store 调用监听函数 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.subscribu(listener)</span><br></pre></td></tr></table></figure></li><li>listener 可以通过 store.getState() 得到新的 state，在 react 中，这时可以触发重新渲染 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newState = store.getState()</span><br><span class="line">  component.setState(newState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="react-redux-工具"><a href="#react-redux-工具" class="headerlink" title="react-redux 工具"></a>react-redux 工具</h4>react-redux 工具提高 redux 操作的简易程度<h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5></li></ol><ul><li><p>react-redux 认为组件分为两种：UI组件（木偶组件），容器组件（智能组件）</p><ul><li><p>父组件 -&gt; 容器组件 =&gt; 负责管理数据和逻辑</p></li><li><p>子组件 -&gt; UI 组件 =&gt; 负责 UI 呈现，不做任何业务逻辑</p></li></ul></li><li><p>安装 react-redux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-redux -S</span><br></pre></td></tr></table></figure><h5 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h5></li><li><p><code>&lt;Provider&gt;</code> 组件<br>使用 react-redux 的时候，在<strong>最外层组件</strong>包裹 Provider 组件，并传入 store </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123; store &#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">, <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Provider 组件作为提供者，为包裹在内的左右容器组件提供 store ，利用 context 树进行传递</li></ul></li><li><p><code>connect()</code> 方法</p><ul><li><p><code>cnnect()</code>函数传入一个组件，返回一个高阶组件</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">let</span> HOC = connect()</span><br><span class="line"><span class="keyword">let</span> HOCcomponent = HOC(UIcomponent)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HOCcomponent</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">exprot <span class="keyword">default</span> connect()(UIcomponent)</span><br></pre></td></tr></table></figure></li><li><p><code>connect()</code>接收两个参数，这两个参数分别为两个函数</p><ul><li><p><code>mapStateToProps()</code></p><ul><li><p><code>mapStateToProps</code>是一个函数。接收 state。建立一个从（外部的）<code>state</code> 对象到（UI 组件的）<code>props</code> 对象的映射关系。执行后返回一个<strong>对象</strong>，里面的每一个键值对就是一个映射。<strong>函数返回什么，props 里就有什么</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (<span class="function">(<span class="params">state</span>) =&gt;</span> &#123; <span class="comment">// 函数可以接收到 state</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state.todos <span class="comment">// 返回 state 里的 todos UI组件里的 props 会接收到 todos，可以直接使用 this.props.todos 来调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>mapStateToProps</code>会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p></li><li><p>可以接收第二参数，第二个参数代表容器组件的 props 如果容器组件的 props 发生改变也会触发 UI 组件的重新渲染</p></li></ul></li><li><p><code>mapDispatchToProps()</code></p><ul><li><p>建立 UI 组件的参数到<code>store.dispatch</code>方法的映射。作为函数时会接收 store的 dispatch 方法，返回值是对象，键值对对应 props 接收方法；如果是对象，每个健名对应一个方法名，键值（函数）会被当做一个actionCreator，返回的 action 会有 redux 自动发出。一般以函数的形式直接返回函数，函数内直接 dispatch.<strong>函数返回什么，props就有什么</strong></p></li><li><p>同样第二个参数为容器组件的 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="function"><span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addTodo (todo) &#123;</span><br><span class="line">      disptach(&#123;</span><br><span class="line">        type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">        todo</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UI 组件直接调用 addTodo 方法即可完成 disptch</span></span><br><span class="line"><span class="built_in">this</span>.props.addTodo(<span class="string">&#x27;doSomething&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>bindActionCreator</code> 方法</p><p>bindActionCreator 方法是 redux 提供的方法，可以将 actionCreator 中的action 集合分别 dispatch ，返回值是一个对象，props 接收这个对象中的键值对</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreator &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> actionCreator <span class="keyword">from</span> <span class="string">&#x27;../store/actionCreator.js&#x27;</span> <span class="comment">// 自己穿件的actionCreator</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps (dispatch) &#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreator(actionCreator, dispatch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 actionCreator 的集合 为 &#123; addtodo:&#123; type: &#x27;addtodo&#x27; &#125;, add: &#123; type: &#x27;add&#x27; &#125; &#125; ，则在 UI 组件 props 中可以这样调用</span></span><br><span class="line"><span class="built_in">this</span>.props.addtodo()</span><br><span class="line"><span class="built_in">this</span>.props.add()</span><br></pre></td></tr></table></figure><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><p>redux 的执行过程中，action 发出后立即执行 reducer 生成state，这时一个同步的过程，那么当我们要执行异步操作会如何呢？</p></li></ul></li></ul></li></ul></li></ul><p>如果我们想要先去经过一个异步操作，再去返回action怎么办，异步逻辑不能写在视图层的组件中，依然需要写在actionCreator中，但是如果有异步操作的话，我们就无法返回action</p><p>这个时候我们就需要使用一些redux的中间件工具：redux-thunk、redux-promise、redux-saga</p><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">参考文档</a></p><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><ul><li><p>中间件的概念：<br>站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p><ol><li>Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</li><li>View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</li><li>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li></ol><p>想来想去，只有发送 Action 的这个步骤，即store.dispatch()方法，可以添加功能。举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对store.dispatch进行如下改造。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dispatching&#x27;</span>, action);</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;next state&#x27;</span>, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对<code>store.dispatch</code>进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。</p><ul><li>中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</li></ul></li><li><p>中间件的用法</p><ul><li><p>配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));<span class="comment">// 当createStore传入第二个参数作为state初始值时，applyMiddleware就是第三个参数</span></span><br></pre></td></tr></table></figure></li><li><p>中间件的顺序有要求，否则不会出正确结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk, promise, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>applyMiddleware()</code></p><p>Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。</p></li></ul></li></ul><ul><li>配置好之后，<code>actionCreator</code>方法的返回值可以是一个函数，这个函数会接受dispatch，在这个方法中我们可以执行异步操作然后直接 dispatch 一个 action<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actionCreator  = &#123;</span><br><span class="line">    <span class="comment">// addNewTodo (title) &#123;// 同步方法直接返回action</span></span><br><span class="line">    <span class="comment">//     let action = &#123; type: ADD_NEW_TODO, title &#125;</span></span><br><span class="line">    <span class="comment">//     return action             </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    addNewTodo (title) &#123;<span class="comment">// 异步方法</span></span><br><span class="line">        <span class="comment">//可以直接返回一个接受dispatch的函数，这样的话我们就可以将异步创建的action直接dispatch</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">            backend.saveTitle(title).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> action = &#123; <span class="attr">type</span>: ADD_NEW_TODO, title &#125;</span><br><span class="line">                dispatch(action)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="react-组件库"><a href="#react-组件库" class="headerlink" title="react 组件库"></a>react 组件库</h4></li><li>ant-design </li><li>ant-mobile</li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interView 准备</title>
      <link href="2020/01/01/Code-Frontend-react-interView/"/>
      <url>2020/01/01/Code-Frontend-react-interView/</url>
      
        <content type="html"><![CDATA[<p>interView 准备</p><ul><li><p>HTML</p><ul><li><p>语义化：根据内容的结构化，选择合适的标签，便于开发者阅读，同时让搜索引擎更好的解析。</p></li><li><p>HTML5部分新标签：</p><ul><li>article</li><li>aside</li><li>details</li><li>header</li><li>footer</li><li>main</li><li>mark</li><li>nav</li><li>progress</li><li>Section</li></ul></li><li><p>viewport：移动设备缩放适配</p><p>meta 标签的<code>name=viewport</code></p><p><a href="https://www.runoob.com/w3cnote/viewport-deep-understanding.html">ppk关于 viewport 的理论</a></p><ul><li><p>layout viewport：浏览器可视区域</p><p>由于移动设备相对来说都比较窄，在现实 pc 端页面的时候，都会出现错误，所以通过设置 viewport 一个比较宽的可视区域来达到移动端显示 pc 端能够正常</p><p>所以一般来说移动设备的 layout viewport 都比浏览器的可视宽度要大</p></li><li><p>visual viewport：代表浏览器可视区域的大小，通常可以通过 <code>window.innerWidth</code>来获取</p></li><li><p>idea viewport：移动设备的理想 viewport。不管设备的像素密度如何，相同的内容在不同的移动设备中都显示相同的效果。因此理想的 idea viewport 的宽度即为设备宽度。</p></li><li><p>设置 viewport：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置了 viewport 等于设备宽度，初始缩放大小和最小缩放大小，不允许用户缩放。</p></li></ul></li></ul></li><li><p>CSS</p><ul><li><p>盒模型</p><ul><li>IE盒模型：border-box；宽高：border、padding+自身宽高</li><li>标准盒模型：content-box；宽高：自身的宽高</li></ul></li><li><p>获取宽高的方法：</p><ul><li>dom.offsetHeight/offsetWidth</li><li>dom.getClientRect：带小数、可以获取相对视窗的位置（可以用于图片懒加载）</li></ul></li><li><p>获得各种宽高的方法</p><ul><li>屏幕宽高(分辨率)：window.screen.width/height</li><li>屏幕工作区域宽高（可用高度，去除工具栏）：window.screen.availWidth/availHeight</li><li>网页全文的宽高：document.body.scrollWidth/scrollHeight</li><li>滚动条卷去的宽高（没有border）：document.body.scrollTop/scrollLeft</li><li>可见区域的宽高（加上border）：document.body.clientHeight/clientWidth</li></ul></li><li><p>BFC</p><p>Block Formatting Context的缩写</p><ul><li><p>Box：css布局的基本单位</p><p>box是css布局的基本单位，一个页面可以看成由许多的box组成。元素的类型和display属性决定了这个Box类型。</p></li><li><p>box有几个不同的类型</p><ul><li>Block-level box：display为block，list-item，table元素。会生成block-level box。</li><li>Inline-level box：display为inline，inline-block, inline-table的怨毒，会生成inline-level box。</li><li>Run-in box：css3中才有。</li></ul></li><li><p>formatting context：css规范中的一个定义，不同的类型有不同的渲染规则，决定了其子元素如何定位，以及和其他元素的关系和相互作用。BFC，即Block-level box的formatting context。</p><ul><li>他的规则是：<ul><li>内部的box会在垂直方向，一个接一个地放置。</li><li>box垂直方向的距离由margin决定。属于<strong>同一个</strong>BFC的两个相邻的box会发生margin重叠（margin重叠问题）</li><li>每个盒子（块/行盒）的margin box的左边，与包含块border box的左边相接触</li><li>BFC的区域不会与float box重叠（自适应两栏布局）</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的元素不会影响外面的元素，反之亦然。</li><li>计算BFC高度时，浮动元素也参与计算（高度塌陷问题）</li></ul></li></ul></li><li><p>创建BFC</p><ul><li>float值不为none</li><li>position的值不是static或relative</li><li>display的值时inline-block、table-cell、flex、table-caption或inline-flex</li><li>overflow的值不是visible</li></ul></li><li><p>几个BFC相关问题</p><ol><li>margin重叠（防止重叠）</li><li>自适应两栏布局</li><li>float元素导致parent高度塌陷（清除浮动）</li></ol></li></ul></li><li><p>居中问题：</p><ul><li>水平居中：<ol><li>内联元素：text-align: center</li><li>不定宽块元素居中：margin: 0 auto;// 需要设置父元素宽度。</li><li>定位居中：left：50%；transform：translateX(-50%);</li></ol></li><li>垂直居中：<ol><li>内联元素垂直居中：height和line-height相同</li><li>flex布局：justify-content: center; align-item: center;</li><li>定位居中：top: 50%;transform: translateY(-50%)</li><li>table布局：.father{display: table}; .children{ display: table-cell; vertical-align: middle;text-align: center}</li></ol></li><li>垂直、水平居中：<ol><li>定位</li><li>flex布局</li></ol></li></ul></li><li><p>画三角形：利用边框透明</p></li><li><p>inline、inline-block和block的区别，为什么image是inline还可以设置宽高</p></li><li><p>js动画和css3动画的区别</p><ul><li>js动画：<ul><li>优点：<ol><li>相比较 css3，对动画的控制比较强，播放暂停，加速都可以控制。</li><li>效果较丰富：如曲线动画</li><li>兼容性相对来说较好</li></ol></li><li>缺点：js在主调用栈中，当调用栈还有其他要处理时，动画卡顿掉帧</li></ul></li><li>css3动画<ul><li>优点：<ol><li>浏览器可以对动画进行优化，可以使用类似requestAnimationFrame的机制</li><li>可以使用硬件加速动画</li></ol></li><li>缺点：<ol><li>对动画的控制较弱</li><li>较复杂的动画实现比较麻烦</li></ol></li></ul></li></ul></li><li><p>Css3新特性、新属性</p><p><a href="https://juejin.cn/post/6844903829679390728#heading-2">CSS3 和 HTML5 新特性一览</a></p><ul><li><p>过渡：transition</p></li><li><p>变形：tranform</p></li><li><p>动画：animation</p></li><li><p>边框：border-radius；border-shadow；border-image</p><p>…</p></li></ul></li></ul></li><li><p>javascript</p><ul><li><p>数据类型</p><ul><li><p>基本数据类型：number、string、boolean、undefined、null、symbol</p></li><li><p>引用数据类型：Object</p><p><strong>这部分包含对象的各种方法；以及继承的toString、valueOf</strong></p><ul><li><p>Date</p></li><li><p>RegExp</p></li><li><p>Array</p></li><li><p>Object</p></li><li><p>各种单体内置对象</p><ul><li><p>Math</p></li><li><p>Array</p></li><li><p>Object</p></li><li><p>Function</p><p>等。。。</p></li></ul></li></ul></li></ul></li><li><p>new的执行过程</p><ul><li><p>如果构造函数返回原始值，return没有任何作用；如果返回的是一个对象，那么这个实例就是这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ins</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Ins(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// test 是Date函数</span></span><br><span class="line">test.name <span class="comment">// Date函数的name</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ins2</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">new</span> Ins2(<span class="string">&#x27;test2&#x27;</span>); <span class="comment">//test2 是 Ins2的实例 </span></span><br><span class="line">test2.name<span class="comment">// test2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>构造函数不需要使用return，返回原始值没有作用，返回对象改变了构造函数的作用，缺省默认返回this</p></blockquote></li><li><p>new 的实现过程</p><ol><li>创建一个空对象，指定这个空对象的原型为函数原型</li><li>通过this将属性和方法添加到这个对象上</li><li>返回这个this</li></ol></li><li><p>自己实现一个new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个对象，原型置顶为函数的原型</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">  <span class="comment">// 绑定obj到函数上，并传入参数执行</span></span><br><span class="line">  fn.call(obj, ...args)</span><br><span class="line">  <span class="comment">// 返回这个对象</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ins = myNew(test, <span class="string">&#x27;Jim&#x27;</span>, <span class="number">20</span>) <span class="comment">// &#123;name: &#x27;Jim&#x27;, age: 20&#125;</span></span><br><span class="line">ins <span class="keyword">instanceof</span> test; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>typeof instanceof</p><ul><li><p>typeof</p><ul><li>typeof 对基本类型使用时返回各自的类型（null 特殊</li><li>typeof对引用类型使用除了Function外都返回Object</li></ul></li><li><p>instanceof</p><p>通过原型链判断是否是某个对象的实例</p><ul><li><p>Symbol.hasInstance</p><p>该方法决定一个对象是否认可被调用对象为它的实例，和instanceof一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo()</span><br><span class="line">f <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br><span class="line">Foo[<span class="built_in">Symbol</span>.hasInstance](f); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>实际上，instanceof操作符会在原型链上寻找这个属性，在ES6中，instanceof操作符会使用 Symbol.hasInstance 函数来确定关系。我们可以自定instanceof的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyInstance</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyInstance.prototype[<span class="built_in">Symbol</span>.hasInstance] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> MyInstance()</span><br><span class="line"><span class="string">&#x27;&#x27;</span> <span class="keyword">instanceof</span> test; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimitiveString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;&#x27;</span> <span class="keyword">instanceof</span> PrimitiveString; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>因此，使用instanceof判断对象是否是构造对象的实例并不是百分百可靠</p></blockquote></li></ul></li></ul></li></ul><ul><li><p>类型转换、隐式类型转换（== ）</p><p><strong>类型转换有三种情况</strong></p><ul><li>转换为boolean</li><li>转换为number</li><li>转换为string</li></ul><p><strong>转换为boolean</strong></p><p>除了undefined、null、false、NaN、0、-0，’’转换为false外，其他都转换为true</p><p><strong>Symbol.toPrimitive</strong></p><p>作为将对象转换为原始值的函数，很多内置操作 都会尝试强制将对象转换为原始值，包括字符串、数值和未制定的原始类型。</p><p><strong>对象转换原始类型</strong></p><p>对象转化原始类型的时候，会调用 <code>valueOf</code>和 <code>toString</code>。</p><ul><li>调用方法视情况而定<ul><li>转换number类型调用valueOf</li><li>转换为string类型调用toString</li></ul></li><li>调用这两种方法的时候需要返回原始类型<ul><li>在调用valueOf的时候如果不是返回原始类型，会调用toString</li><li>若toString返回值不是原始类型，会报错</li></ul></li><li>若有Symbol.toPrimitive，则优先级最高</li></ul><p><strong>四则运算</strong></p><ul><li><p>加法运算符的规则</p><ul><li><p>运算符一方为字符串，那么会把另一方转换为字符串</p></li><li><p>如果一方不是字符串或数字，会将它转换为字符串或数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;1&#x27;</span><span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 41,2,3</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>+ +<span class="string">&#x27;b&#x27;</span> <span class="comment">// &#x27;aNaN&#x27; 这里 +b 为 NaN</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>乘法运算符</p><ul><li>如果一方是数字，则另一方转换为数字</li></ul></li><li><p>比较运算符</p><ul><li>如果是对象，则为对象转换原始值的规则</li><li>如果是字符串，比较 unicode 字符串索引</li><li>如果是boolean，转换为数字</li></ul></li></ul><p><strong>==的隐式转换</strong></p><p>对于 <code>==</code>，如果对比双方的类型不一致，则会发生隐式类型转换。</p><ul><li>判断的大致流程<ol><li>首先判断两者类型是否相同，相同则比较大小</li><li>类型不相同则发生隐式转换<ol><li>先判断是否对比<code>null</code>和<code>undefined</code>，是则返回true</li><li>是否 <code>string</code>和<code>number</code>对比，是则string转换number</li><li>是否有一方是<code>boolean</code>，是则先把boolean转换为number，再判断</li><li>是否一方为<code>object</code>且另一方是<code>string</code>、<code>number</code>、<code>symbol</code>，是则把object转换为原始类型再进行判断</li></ol></li></ol></li></ul></li><li><p>this的问题，结合call、bind、apply</p><ul><li>this的指向问题</li><li>改变this的指向</li><li>call、bind、apply的区别</li></ul></li><li><p>手写call、bind、apply</p><ul><li>call、apply的思路<ol><li>对绑定对象的处理，如果为原始值，需要转换为包装对象</li><li>把函数绑定到绑定的对象上（使用Symbol做临时对象防止key重复）</li><li>执行对象上的函数（即this，由于是在对象上调用this，故此时函数内部的this指向绑定的对象）</li><li>删除临时属性，返回结果</li><li>apply的处理和call大体相同，需要添加对第二个参数非数组/类数组的判断</li></ol></li><li>bind<ol><li>返回一个新函数，其内部调用函数的call，绑定对象为传入的对象</li><li>需要对返回函数的原型进行处理</li><li>需要对通过new调用返回函数处理（new调用的this为返回函数的this，否则为处理过的绑定对象）</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">thisArg = <span class="built_in">window</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">thisArg = <span class="built_in">Object</span>(thisArg) <span class="comment">// 原始值时为原始值的包装对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> S = <span class="built_in">Symbol</span>(<span class="string">&#x27;tempVar&#x27;</span>) <span class="comment">// 用Symbol临时变量，同时防止key重复</span></span><br><span class="line">  thisArg[S] = <span class="built_in">this</span> <span class="comment">//把函数绑定到指定的对象上</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[S](...args) <span class="comment">// 执行函数得到结果</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[S] <span class="comment">// 删除临时变量</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (o &amp;&amp;                                    <span class="comment">// o不是null、undefined等</span></span><br><span class="line">       <span class="keyword">typeof</span> o === <span class="string">&#x27;object&#x27;</span> &amp;&amp;                <span class="comment">// o是对象</span></span><br><span class="line">       <span class="built_in">isFinite</span>(o.length) &amp;&amp;                   <span class="comment">// o.length是有限数值</span></span><br><span class="line">       o.length &gt;= <span class="number">0</span> &amp;&amp;                        <span class="comment">// o.length为非负值</span></span><br><span class="line">       o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp;    <span class="comment">// o.length是整数</span></span><br><span class="line">       o.length &lt; <span class="number">4294967296</span>)                  <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">thisArg = <span class="built_in">window</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">thisArg = <span class="built_in">Object</span>(thisArg) <span class="comment">// 原始值时为原始值的包装对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> S = <span class="built_in">Symbol</span>(<span class="string">&#x27;tempVar&#x27;</span>) <span class="comment">// 用Symbol临时变量，同时防止key重复</span></span><br><span class="line">  thisArg[S] = <span class="built_in">this</span> <span class="comment">//把函数绑定到指定的对象上</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> args_ = <span class="built_in">arguments</span>[<span class="number">1</span>] <span class="comment">// 取得参数数组</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(args_) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(args_) &amp;&amp; !isArrayLike(args_)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TypeErrro(<span class="string">&#x27;myApply 第二参数必须是数组或类数组对象&#x27;</span>) <span class="comment">//第二个参数不为数组或类数组则抛出错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(args_)</span><br><span class="line">      result =  thisArgs[S](...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = thisArg[S]()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> thisArg[S] <span class="comment">// 删除临时变量</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind的简单实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    thisArg = <span class="built_in">window</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    thisArg = <span class="built_in">Object</span>(thisArg)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args_</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.call(thisArg, ...args, ...args_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bind 优化实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> thisFn = <span class="built_in">this</span> <span class="comment">// 保存原函数相关内容</span></span><br><span class="line"><span class="keyword">const</span> bindFunction = <span class="function"><span class="keyword">function</span>(<span class="params">...args_</span>) </span>&#123; <span class="comment">// 有第二个参数</span></span><br><span class="line">    <span class="keyword">const</span> isNew = <span class="built_in">this</span> <span class="keyword">instanceof</span> bindFunction; <span class="comment">// 返回的函数是否有通过new 调用（通过new调用的this会变为返回的函数的this</span></span><br><span class="line">    <span class="keyword">const</span> context</span><br><span class="line">    <span class="keyword">if</span>(isNew) &#123;</span><br><span class="line">      context = <span class="built_in">this</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">        context = <span class="built_in">window</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="built_in">Object</span>(thisArg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thisFn.call(context, ...args, ...args_)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 改变新函数的原型指向原函数原型</span></span><br><span class="line"> <span class="keyword">if</span>(thisFn.prototype) &#123; <span class="comment">// 存在原函数没有原型的情况，如箭头函数</span></span><br><span class="line">    bindFunction.prototype = <span class="built_in">Object</span>.create(thisFn.prototype)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> bindFunction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>深浅拷贝</p><ul><li><p>浅拷贝</p><p>创建一个新对象，是原始对象的精确拷贝，若缘对象中有引用对象则新对象会影响原始对象</p><ul><li>Object.assign</li><li><code>...</code>扩展</li></ul></li><li><p>深拷贝</p><p>从内存中完全复制一份一样的，新对象不会影响原始对象。对象的深拷贝存在很多边界问题，比如原型链的处理，DOM处理等。</p><ul><li>JSON.stringify(会存在JSON.stringify的序列化问题)<ul><li>JSON.stringify的序列化问题<a href="https://juejin.cn/post/6844904016212672519">你不知道的JSON.stringfy的威力</a><ul><li>对象中有undefined、null、symbol、function会忽略</li><li>数组中的undefined、null、symbol、function会处理为null</li></ul></li></ul></li></ul></li></ul></li><li><p>立即执行函数</p><p>用function定义函数后立即调用，即叫立即执行函数（立即调用的函数表达式IIFE(Imdiately Invoked Function Expression)</p><ul><li><p>js代码执行时，会对函数声明对函数进行解析（函数提升），而函数表达式，当逐行解析到它时才会解析。</p></li><li><p>正因为函数提升，导致函数声明的函数不能立即执行。</p></li><li><p>匿名函数不能单独存在，所以没有立即执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>只有函数表达时能够立即执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// test</span></span><br></pre></td></tr></table></figure></li><li><p>使用圆括号的两种常用的立即执行函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">666666</span>)&#125;)()</span><br><span class="line">((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">66666</span>)&#125;)())</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>数组去重</p><ul><li><p>ES6方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeatArr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reault = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(repeatArr))</span><br></pre></td></tr></table></figure></li><li><p>遍历：基本数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeatArr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用空数组存储非空值，遍历原始数组，用indexOf或者includes来查询是否存在，不存在则推入值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(res.indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">       res.push(arr[i])</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.lastIndexOf(item) === index) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用对象 key 不可重复</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj[arr[i]]) &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    obj[arr[i]] = arr[i]</span><br><span class="line">    result.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p>对象方法</p></li><li><p>异步编程</p><ul><li>callBack</li><li>es6后续异步编程方法<ul><li>promise<ul><li>手写promise（promise/A+规范）</li></ul></li><li>async/await<ul><li>async/await的实现（promise的语法糖）</li></ul></li><li>genertor</li></ul></li></ul></li><li><p>闭包 **</p><p>函数A内部有一个函数B，函数B可以访问函数A内部变量，这个函数B就是一个闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B()</span><br></pre></td></tr></table></figure><p>有一种说法是函数嵌套函数，返回这个函数可以访问外层函数的变量，这个定义并没有很全面。</p></li><li><p>事件</p></li><li><p>eventloop **</p><ul><li><p>通常结合promise、setTimeOut的问题</p><ul><li>浏览器为多进程应用程序</li><li>一个进程有多个线程</li><li>JS是单线程的，通过事件队列达到异步调用的效果</li><li>JS分为同步任务和异步任务</li><li>同步任务都在JS引擎线程中执行，形成一个执行栈（调用栈），执行栈采用的是后进先出的策略（LIFO）</li><li>当调用栈清空，主线程空闲的时候，会将放入到任务队列中的事件依次推入到调用栈中执行。</li><li>调用栈有大小，超出栈时会报错，就是我们平时所说的爆栈</li></ul></li><li><p>宏任务和微任务</p><ul><li><p>宏任务（Tasks）：每次调用栈调用的代码可以当作一个宏任务，包括</p><ul><li>Javascript的所有代码</li><li>setTimerout</li><li>setInterval</li><li>I/O</li><li>UI render</li></ul><p>即通常上宿主环境提供的为宏任务</p></li><li><p>微任务</p><ul><li>Process.nextTick(Node)</li><li>Promise</li><li>MutationObserver</li></ul><p>即语言标准提供的为微任务</p></li></ul></li></ul></li><li><p>原型链 </p><ul><li><p>原型：</p><ul><li><strong>函数上的prototype属性，指向原型对象</strong>，默认情况下，所有原型对象自动获得一个construction属性，指向与之关联的构造函数，<strong>默认的constructor指向它本身</strong>。原型对象除了自动获得的contructor属性外，<strong>其余均继承自Object</strong></li><li>调用构造函数生成的实例，其内部的[[prototype]]指针指向构造函数的原型，默认情况下<strong>没有访问这个[[prototype]]特性的标准方法</strong>，但是不同的浏览器中各自实现了。因此对象实例不能通过<code>.prototype</code>得到（为undefined），可以通过<code>Object.getPrototypeOf()</code>获得一个实例对象的原型，或者通过宿主环境提供的特殊属性。</li></ul><p><strong>概括来说既是：每个构造函数有一个prototype的原型对象，原型对象有一个contructor指回构造函数，而实例有一个内部指针[[prototype]]指向原型</strong></p></li><li><p>原型链：<strong>对象实例和原型形成的链条，即为原型链</strong></p></li><li><p>正常的原型链<strong>终止于<code>Object</code>的原型</strong></p></li><li><p><code>Object</code>原型的原型是**<code>null</code>**</p></li><li><p>对象实例上寻找属性和方式时，先找对象本身的属性和方法，再寻找原型链上的</p></li><li><p>相关方法</p><ul><li><code>Object.getPrototypeof()</code>获得原型</li><li><code>Person.prototype.isPrototypeof()</code>构造函数的原型是否是某个实例的原型</li></ul></li></ul></li><li><p>继承 **</p><p><strong>通过原型链获得属性和方法。</strong></p><ul><li><p>ECMAScript的继承都是实例继承（很多语言都实现了接口继承和实例继承）</p></li><li><p>继承方式</p><ul><li><p>原型链继承：改变原型指向另一个对象</p></li><li><p>组合继承：通过子类调用<code>Parent.call(this)</code>继承父类的实例属性和方法，通过指定子类的原型为<code>new Parent()</code>继承父类的原型属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">&#x27;Jim&#x27;</span>)</span><br><span class="line">child.colors <span class="comment">// [&#x27;blue&#x27;, &#x27;red&#x27;]</span></span><br><span class="line">child.sayName() <span class="comment">// Jim</span></span><br></pre></td></tr></table></figure><ul><li>缺点：子类原型通过调用父类来赋值，这样造成子类实例的属性和实例原型上有相同的一份属性，造成内存的浪费</li></ul></li><li><p>寄生组合式继承：优化掉组合继承的缺点即是寄生组合式继承。在赋值子类原型时只继承父类的原型，并且把contructor指向子类本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>(Parent.prototype)</span><br><span class="line">child.prototype.constructor = Child</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>模块化：es6模块化（ES Module），commonJS，</p></li><li><p>es6</p><ul><li>var、let、const</li><li>箭头函数</li></ul></li><li><p>设计模式 ** </p><p><em>设计模式在另一篇文章</em></p></li><li><p>性能优化</p><ul><li><p>图片懒加载 *</p></li><li><p>前端缓存</p></li><li><p>节流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throll</span>(<span class="params">fn, duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> now = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Date</span>.now() - now &gt; duration) &#123;</span><br><span class="line">      now = <span class="built_in">Date</span>.now()</span><br><span class="line">      fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>防抖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimerout(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn()</span><br><span class="line">    &#125;, duration)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>预加载、预渲染</p></li><li><p>懒加载、懒执行</p></li><li><p>CDN</p></li><li><p>回流、重绘</p></li></ul></li><li><p>浏览器</p><ul><li>cookie、sessionStorage、localStorage<ul><li>相同点：<ul><li>都是同源。</li><li>存储数据都是以字符串形式</li></ul></li><li>不同点：<ul><li>cookie数据始终在同源http请求中携带，session和localStorage不会自动传给服务器。</li><li>cookie数据大小不能超过4k，localStorage、sessionStorage都比较大，可以保存5M的信息</li><li>sessionStorage不可以跨标签页，cookie和localStorage可以跨页同源共享。</li><li>sessionStorage页面会话关闭及失效，cookie过了设置时间后失效，localStorage需要手动清除</li></ul></li></ul></li><li>DOM<ul><li>事件委托</li><li>回流、重绘</li></ul></li><li>从输入URL到渲染页面的过程 **</li><li>安全防范<ul><li>xss</li><li>CSRF</li><li>点击劫持</li><li>中间人攻击</li></ul></li></ul></li><li><p>http</p><ul><li><p>常见状态码</p></li><li><p>缓存</p></li><li><p>请求方式及区别 **</p><ul><li><p>副作用</p><p>副作用是指对服务器上的资源做改变，搜索是无副作用的，注册是有副作用的</p></li><li><p>幂等性</p><p>对同一操作发起的一次请求或多次请求结果是一致的，不会因为多次操作产生副作用。</p></li><li><p>get和post区别</p><ul><li><p>本质上get和post只是报文格式的不同，只是HTTP协议中的两种请求方式。</p></li><li><p>get多用于无副作用，幂等的场景；post多于副作用，不幂等的场景。</p></li><li><p>根据浏览器，通常有</p><ul><li><p>get请求可以被缓存，post不能（通过设置可以）</p></li><li><p>编码类型不同</p></li><li><p>get根据浏览器不同参数有长度限制，post没有参数长度限制</p></li><li><p>get请求的参数在请求行可见，post的在body中（通常</p><p>技术上来讲，get和post都可以添加body，不过不同浏览器会有不同的限制</p></li></ul></li></ul></li></ul></li><li><p>三次握手四次挥手及原因</p><ul><li><p>三次握手</p><ol><li><p>客户端给服务端发送一个SYN报文，并指明客户端的初始序列号，此时客户端处于SYN_SEND 状态。</p><p>第一次发送不能携带数据。<strong>此时可以知道客户端的发送能力、服务端的接收能力没问题</strong></p></li><li><p>服务端收到客户端的SYN报文，会发送自己的SYN报文，指定自己的初始化序列号ISN，把客户端的ISN + 1作为ACK，此时服务端处于SYN_RCVD状态，</p><p><strong>此时可以知道服务端的发送能力没问题</strong></p><p>服务端发送SYN报文之后，就处于SYN_RCVD状态，双方还没有建立连接，服务器会把此中状态下的请求连接放在一个队列中，这个队列就是<strong>半连接队列</strong>，建立连接后的队列即为<strong>全连接队列</strong>。队列满了会发生丢包</p><p><strong>SYN-ACK重传</strong>：服务端发送完SYN-ACK包后，如果未收到客户端确认包，服务器会进行重传，重传间隔渐进</p></li><li><p>客户端收到服务端的SYN报文，会发送一个ACK报文，客户端进入ESTABLISHED状态，服务端收到报文后也会进入ESTABLISHED状态</p><p><strong>此时可以知道客户端的接收能力没问题</strong></p></li></ol><ul><li>为什么是三次握手：要确认双方的接收和发送能力都没问题。</li><li>三次握手可以携带数据吗：第一二次不能携带数据，意在减少服务器收到攻击的可能，第三次已经建立连接，可以携带数据。</li><li>SYN攻击：<strong>服务端资源分配是在第二次握手，客户端资源分配是在第三次建立连接后</strong>，当大量伪造的SYN报文发送给服务端时，服务端给这些分配资源但是又得不到客户端的回应，就会造成这些伪造的连接请求占用半连接队列，正常的SYN报文因为半连接队列满而丢弃，从而引起网络拥堵甚至瘫痪。SYN攻击时一种典型的DoS/DDoS攻击</li></ul></li><li><p>四次挥手</p><ul><li>半连接：TCP连接提供了连接的一端在结束它的发送后还能接受来自另一端数据的能力</li><li>由于<strong>半连接</strong>的缘故，TCP关闭连接需要发送四次包。而客户端和服务端均可以主动发起挥手动作。</li></ul><p>以客户端开始</p><ol><li>客户端发送<strong>连接释放报文</strong>（FIN报文，包含一个序列号），进入FIN_WAIT1状态，等待服务端确认。</li><li>服务端收到释放报文后发送<strong>确认报文</strong>（ACK，客户端序列号+1的ACK），进入CLOSE_WAIT。此时TCP进入<strong>半连接状态</strong></li><li>服务端所有数据发送完毕，发送<strong>连接释放报文</strong>（FIN报文），进入LAST_ACK状态，等待客户端确认</li><li>客户端收到连接释放报文后，发送<strong>确认报文</strong>（ACK），客户端进入TIME_WAIT状态。此时TCP未释放，在2MSL后客户端进入CLOSED状态</li></ol><p>如果是服务端主动挥手，则服务端需要进入进入TIME_WAIT状态。通常情况是客户端发起挥手，进入TIME_WAIT状态</p><ul><li>为什么挥手需要四次：当服务端收到FIN报文后，可能还需要传输数据不能立即关闭，此时需要先回复确认报文（ACK），等发送完毕才能发送FIN报文，故多了一次，需要四次挥手</li><li>MSL时间：Maximum Segment Lifetime，最大报文生存时间。</li><li>2MSL等待的意义：<ul><li>保证客户端最后一个ACK报文能够到达服务端。当最后一个ACK报文丢失时，服务端会重传一个FIN+ACK报文，客户端重传一个ACK报文进入2MSL的等待状态。</li><li>防止“已失效的连接请求报文段”出现在本连接中。客户端在2MSL时间段，可使本连接持续时间内产生的所有报文段从网络中消失，下一个新的连接中不会出现这种旧的连接请求报文段。</li></ul></li></ul></li></ul></li><li><p>HTTP内容</p><ul><li><p><strong>HTTP请求报文整体内容包括</strong></p><ul><li>HTTP报文首部<ul><li>请求的报文首部<ul><li>请求行</li><li>请求首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul></li><li>响应报文首部<ul><li>状态行</li><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul></li></ul></li><li>HTTP报文主体</li></ul></li><li><p>请求行/状态行</p><ul><li>可以区分请求方式</li><li>状态<ul><li>常用状态码<ul><li>2XX<ul><li>200：成功</li><li>204：请求成功，但响应报文没有实体主体部分</li><li>206：进行范围请求</li></ul></li><li>3XX<ul><li>301：永久重定向</li><li>302：临时重定向</li><li>303：资源在另一个URL，应该用get请求</li><li>304：允许访问，但请求未满足。如客户端发送请求被允许，但是请求内容没有改变，服务器返回304，从缓存中取出内容</li></ul></li><li>4XX<ul><li>400：请求报文语法错误</li><li>401：发送的请求需要有通过HTTP验证的验证</li><li>403：资源的访问被服务器拒绝</li><li>404：没有找到资源</li></ul></li><li>5XX<ul><li>500：服务器执行请求时发生错误</li><li>501：服务器不支持当前请求的某些功能</li><li>503：服务器暂时处于超负载或正在停机维护</li></ul></li></ul></li></ul></li></ul></li><li><p>首部：分请求和相应，他们两个有一些共同的首部字段</p><ul><li><p>通用字段</p><ul><li><p>Cache-Control：缓存行为</p><ul><li><p>强缓存：控制字段为Cache-Control和Expires，Cache-Control优先级最高。Cache-Control设置max-age（Expires设置GMT时间格式，在时间内），如果在声明周期时间内命中缓存，返回200，</p></li><li><p>协商缓存</p><p>利用Last-Modified , If-Modified-Since 和 ETag , If-None-Match来实现，命中缓存返回304</p></li></ul></li><li><p>Connection：浏览器想要优先使用的链接类型，如keep-alive</p></li><li><p>Date：报文创建时间</p></li><li><p>Pragma：报文指令</p></li><li><p>Via：代理服务器相关信息</p></li><li><p>Transfer-Encoding：传输编码方式</p></li><li><p>Upgrade：要求客户端升级协议</p></li><li><p>Warning：警告</p></li></ul></li><li><p>请求首部：只列了一部分</p><ul><li>Accept：能正确接收的媒体内容</li><li>Accept-Charset：能正确接收的字符集</li><li>User-Agent：客户端信息</li><li>Range：请求某个内容的一部分</li><li>Referer：浏览器所访问的前一个页面</li></ul></li><li><p>相应首部</p><ul><li>Accept-Ranges：是否支持某些种类的范围</li><li>Age：资源在代理缓存中存在的时间</li><li>ETag：资源标识符</li><li>Server：服务器名</li><li></li></ul></li></ul></li><li><p>实体</p><ul><li><h2 id="请求实体"><a href="#请求实体" class="headerlink" title="请求实体"></a>请求实体</h2></li><li>相应实体</li></ul></li></ul></li><li><p>跨域</p><ul><li><p>协议域名端口不相同</p></li><li><p>跨域解决方法</p><ul><li><p>代理</p></li><li><p>jsonp</p><ul><li><p>原理/执行过程</p><ul><li><p>前端定义解析函数</p></li><li><p>通过 query string 的方式，包装到 script 标签的 src 属性上</p></li><li><p>后端获取到参数，以执行函数的形式返回给前端</p></li><li><p>前端得到返回后，由于是script，会执行解析函数</p><figure class="highlight html"><figcaption><span>jsonp前端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.jsonpCallback = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;http://localhost:8080/api/jsonp?id=1&amp;cb=jsonpCallback&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>node后端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> items = [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;title1&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;title2&#x27;</span> &#125;]</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">&#x27;/api/jsonp&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; cb, id &#125; = ctx.query;</span><br><span class="line">    <span class="keyword">const</span> title = items.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id == id)[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123;title&#125;)&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;listen 8080...&#x27;</span>)</span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><p>七层结构</p><ul><li></li></ul></li><li><p>tcp/udp及区别</p><ul><li>tcp<ul><li>需要建立连接：建立连接需要三次握手四次挥手</li><li>可靠、有序：有解决数据丢包、顺序不对和流量控制的机制</li><li>效率较低：tcp首部开销较大</li><li>只能一对一</li></ul></li><li>udp：<ul><li>面向无连接：不需要建立连接即可发送数据，也不会对数据做处理</li><li>不可靠：没有阻塞控制，以恒定的速率发送数据，网络不好会发生丢包</li><li>高效：udp的头部开销小</li><li>传输方式：一对一，一对多，多对多，多对一，即单播，多播，广播的功能</li><li>应用场景：直播，游戏</li></ul></li></ul></li><li><p>HTTP1/HTTP2</p><ul><li><p><a href="https://juejin.cn/post/6956046759428636708#heading-2">关于网络相关</a></p></li><li><p>http1.1和http2.0的主要区别</p><ul><li><p>http1.1</p><ul><li><p>相较1.0版本，优化了长连接，并且默认使用长连接；强制客户端提供 Host 首部管线化；<code>Cache-Control</code>、<code>ETag</code>等缓存的相关扩展</p></li><li><p>问题：</p><ul><li><p>线头阻塞：TCP 连接上只能发送一个请求，前面的请求未完成，后面的请求排队等待</p></li><li><p>多个 TCP 连接</p><p>http1.1 的管线化支持请求并发，但难实现，所以 http1.1 请求并发依赖于多个 TCP 连接，建立 TCP 连接成本相对较高，还存在慢启动。</p></li><li><p>头部冗余</p><p>每次请求都会带上cookie、user-agent等相同的首部信息</p></li><li><p>采用文本可是</p><p>内容传输采用文本格式，首部未压缩</p></li></ul></li></ul></li><li><p>http2.0</p><ul><li><p>二进制分层</p><p>对传输数据进行二进制编码</p><ul><li><p>帧</p><p>通信的基本单位。http2.0将一个通信分成了 HEADERS frame 和 DATA frame。</p></li><li><p>流</p><p>建立在 TCP 连接上的双向字节流，即多个帧组成一个流</p><p>特定请求的帧只能在同一个流上，即一个流即一个请求</p></li></ul></li><li><p>多路复用</p><p>所有连接通信（流）都在同一个 TCP 连接上，从而实现真正的并发，避免线头阻塞。</p></li><li><p>头部压缩</p><p>使用 HPACK 压缩格式对传输的 header 进行编码，在客户端和服务端保存维护同一个索引表，第一次需要传输完整的内容，后续只需要传输索引即可。</p></li><li><p>服务端推送</p><p>服务端预测客户端需要的资源，主动推送到客户端。（chrome 客户端废弃）</p></li></ul></li></ul></li></ul></li><li><p>从输入URL到渲染过程</p><ul><li></li></ul></li><li><p>react</p><ul><li><p>react</p><ul><li><p>class 组件更新流程：</p><p>组件更新流程主要分为两个阶段</p><ol><li>调和阶段，主要体现在虚拟 DOM 的 diff 算法上</li><li>提交阶段，将 diff 阶段产生的结果应用到真实 DOM 上</li></ol><p>在调和阶段：</p><ol><li><p>state 或 props 改变，触发更新流程</p></li><li><p>执行生命周期的 <code>componentWillReceiveProps</code></p><p>这个生命周期函数的执行的先觉条件是</p><ol><li>props 前后有差别</li><li>没有使用 <code>getDerivedStateFromProps</code>和<code>getSnapshotBeforeUpdate</code></li></ol><blockquote><p>现版本中，<code>componentWillReceiveProps</code>官方已不推荐使用，因为在调和阶段可能会被打断，该函数会重新执行</p></blockquote></li><li><p>执行<code>getDerivedStateFromProps</code>获取最新的 state</p></li><li><p>判断是否更新组件</p><ol><li>是否使用了 <code>shouldComponentUpdate</code>函数，存在则调用</li><li>不存在则判断组件是否继承自 PureComponent，是则浅层比较前后 props 和 state 得出结果。</li></ol></li><li><p>得出结果需要更新组件的话，调用 <code>componentWillUpdate</code>，然后处理<code>componentDidUpdate</code>及<code>getSnapshotBeforeUpdate</code>函数。</p></li><li><p>调用<code>render</code>函数获取到最新的 <code>child</code>，进行 diff 决定 <code>child</code>是否需要更新。</p></li></ol></li><li><p>diff 过程</p><p>diff 只会在相同的层级进行比较，新的 dom tree 对应层级不相同的话直接进行删除创建。在一次循环</p><p>相同层级的比较</p><p>​    如果是 component 的话进行 dom tree 的比较，重复以上操作</p><p>​    如果不是形同的组件则直接销毁重新创建新组件。</p></li></ul></li><li><p>redux</p><ul><li><p>核心</p></li><li><p>三大原则：</p><ul><li><p>单一数据源：只存在唯一一个store</p></li><li><p>state是只读的：唯一改变state的方法是触发action</p></li><li><p>使用纯函数来执行修改：为了描述action如何修改state，需要编写 reducer</p><p>reducer接收state和action，返回新的state</p></li></ul></li><li><p>编写redux</p><ul><li><p>设计state结构</p></li><li><p>action</p><ul><li>action约定有一个 type 属性表示执行的操作以及一个有效荷载。</li></ul></li><li><p>action处理（reducer）</p><ul><li>开发 reducer：reducer作为纯函数，需要遵循一定的规则<ul><li>不能修改传入的参数</li><li>不能执行有副作用的操作，入网络请求和路由跳转</li><li>调用非纯函数，入 Date.now 或 Math.random</li></ul></li></ul><figure class="highlight javascript"><figcaption><span>action</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEFAULT_STATE = &#123;</span><br><span class="line">  todoList: [</span><br><span class="line">    &#123;</span><br><span class="line">      title: <span class="string">&#x27;q2&#x27;</span>,</span><br><span class="line">      id: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">prevState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...prevState</span><br><span class="line">    todoList: prevState.todoList.concate(&#123;<span class="attr">title</span>: <span class="string">&#x27;123e&#x27;</span>, <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="string">&#x27;addTodo&#x27;</span>: addTodo</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">act</span>(<span class="params">prevState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = actions[action.type]?.(prevState) || &#123;...prevState&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">prevState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> act(prevState, action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, DEFAULT_STATE)</span><br></pre></td></tr></table></figure></li><li><p><code>createStore(reducer, [preloadState], [enhancer])</code>：</p><ul><li>reducer</li><li>preloadState：默认的state，redux在初始化过程中会进行一次dispatch，将reducer中的state进行关联，取得默认值，覆盖掉参数默认值。如果省略了 preloadState，直接添加 enhance，redux 内部会自动识别。</li><li>Enhancer：增强，可以增强redux的功能。<ul><li>enhancer 需要返回一个 返回函数的 函数，enhancer 的执行决定 <code>enhancer(createStore)(reducer, preloadedState)</code></li></ul></li></ul></li><li><p><code>combineReducers</code>：多个 reducer 拼装。</p><ul><li><p>使用combineReducers之后，reducer必须返回一个新值，reducer的返回值必须是一个非 undefined 的值。（源码中初次调用 reducer 时传入了undefined）。</p><blockquote><p>combineRedcers 函数内部有undefined和未匹配action的检测。</p></blockquote></li></ul></li><li><p>applyMiddleware(…middlewares)</p><ul><li><p>redux提供的将传入的中间件按照顺序注册的原生函数，注册的中间件将会按照顺序执行</p><p>applyMiddleware 执行后会形成一个洋葱模型，第一个 middleware 在最外层。</p><p>源码位置👉<code>funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlf3u5myaj30d20chwer.jpg" style="zoom:50%;" /><p>每次执行 action 时，都会从第一个/最外层 执行。每一层都会接受下一层的返回，最后一层则会接收 store.dispatch</p></li><li><p>middleware：通过 <code>applyMiddleware</code> 注册的中间件都会接收一个包含 <code>getState</code>和<code>dispatch</code>的参数，返回值是一个函数，这个函数接收一个 <code>next</code>的参数，next 指向下一个中间件的 <code>dispatch</code>，最后一个中间件则是 <code>store.dispatch</code>，这个函数需要返回</p></li></ul></li><li><p>store</p><ul><li><code>getState</code>：获取最新的 State</li><li><code>dispatch</code>：分发一个action，返回值为action</li><li><code>subscribe</code>：注册监听器<ul><li>subscribe返回一个函数注销监听器</li></ul></li><li><code>replaceReducer</code>：使用新的 reducer 取代原来 reducer</li></ul><figure class="highlight jsx"><figcaption><span>store</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [todoList, setTodoList] = useState(store.getState().todoList)</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> unsubscribe = store.subscribe(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setTodoList(store.getState().todoList)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">const</span> addTodo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    store.dispatch(&#123;</span><br><span class="line">      type: <span class="string">&#x27;addTodo&#x27;</span>,</span><br><span class="line">      payload: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &#123;todoList.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>)&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;button onClick=&#123;addTodo&#125;&gt;add&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步action：middleware接管</p><p>我们可以通过包装dispatch，达到异步效果。</p><p>通过包装 dispatch 的方法就是 middleware 的内容。</p><p><a href="https://www.cntofu.com/book/4/docs/advanced/Middleware.md">middleware实现</a></p><p>👆middleware 的模拟实现过程</p></li></ul></li></ul></li></ul></li></ul><pre><code>    middleware的作用就是**接管从dispatch一个action到执行reducer之间的过程**，期间可以进行有副作用的操作。    - 使用 `redux-thunk`执行异步action：注册 `redux-thunk`中间件后，可以执行 function 类型的action，thunk没有做其他额外操作      使用 thunk 后，如果 action 是 function 执行 function，如果是一个对象，使用 `store.dispatch`分发这个对象。    <figure class="highlight javascript"><figcaption><span>异步action</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createStore</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk form <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, DEFAULT_STATE, applyMiddleware(thunk))</span><br><span class="line"></span><br><span class="line"><span class="comment">// action 改造actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">actionCreator</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="string">&#x27;addTodo&#x27;</span>: <span class="function">(<span class="params">payload</span>) =&gt;</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: <span class="string">&#x27;addTodo&#x27;</span>,</span><br><span class="line">        payload: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> actions[action.type](action.payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 修改 addTodo 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; actionCreator &#125; <span class="keyword">from</span> <span class="string">&#x27;action&#x27;</span></span><br><span class="line"><span class="keyword">const</span> addTodo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: <span class="string">&#x27;addTodo&#x27;</span>,</span><br><span class="line">    payload: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - `redux-saga`：用于管理 redux 的一步操作的中间件，redux-saga 通过创建 sagas 将所有的一步逻辑收集在一个地方，集中处理      - 相比 redux-thunk 的在 action 创建时调用，saga 在应用启动时调用，后监听发起的 action，相当于应用启动了一个后台线程，当匹配到有 action 时，执行相应的操作。        <figure class="highlight javascript"><figcaption><span>saga.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery, select, all, delay, put&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello saga&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">increseAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;INCRESE_ASYNC&#x27;</span>, <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> select(<span class="function"><span class="params">state</span> =&gt;</span> state)</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;</span><br><span class="line">      type: <span class="string">&#x27;update&#x27;</span>,</span><br><span class="line">      payload: data + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([</span><br><span class="line">    helloSaga(),</span><br><span class="line">    increseAsync()</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        <figure class="highlight javascript"><figcaption><span>createStore.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rootSaga <span class="keyword">from</span> <span class="string">&#x27;./saga&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(sagaMiddleware));</span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"></span><br></pre></td></tr></table></figure>        <figure class="highlight javascript"><figcaption><span>使用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件内</span></span><br><span class="line">handler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: <span class="string">&#x27;INCRESE_ASYNC&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 的actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="title">funciton</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;update&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> action.payload</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内 dispatch 一个 action 后，saga 匹配到此 action 并经过处理后发出 reducer 的action 修改 state</span></span><br></pre></td></tr></table></figure>- 结合 react-redux  - react-redux 是 redux 作者编写的适用于 react 的库。  - react-redux 的规范，就是应用分为容器组件和UI组件，容器组件负责数据和业务逻辑，不负责 UI 呈现，且内部有状态（redux 的 state），可以使用 redux 的api；容器组件负责 UI 的呈现，所有数据由外部提供，不使用 redux 的 API。  - API    - connect：高阶组件      - 通过 connect 包裹的组件，会生成一个容器组件，connect 的意思就是把容器组件和 UI 组件连接起来。      - mapStateToProps：connect 接收的第一个参数，此函数接收 store 的 state 和 组件的 props，需要返回一个对象，映射到 UI 组件的 props 上      - mapDispatchToProps：connect 接收的第二个参数，如果是参数，此函数接收一个 store.dispatch 和组件的 props，返回一个方法组成的对象映射到组件的 props 上；如果此参数是对象，则对象的值必须是一个 actionCreator 的函数`(...args) =&gt; (&#123;type: &#39;&#39;&#125;)`    - Provider      通过 Provider 包裹的组件内部会得到 store。</code></pre><ul><li>mobx</li></ul><ul><li><p>typescript</p><ul><li><p>范型：在定义的时候不制定特定类型，而在使用的时候再制定类型。通过使用<strong>类型变量</strong>，达到输入与输出同类型的情况</p><ul><li>为什么要使用范型：</li></ul></li><li><p>void和undefined、null的：</p><p>函数没有返回值时可以用void，undefined时变量的类型，不能是函数的返回值。</p><p>undefined时所有类型的子集，而void不是。</p></li></ul></li><li><p>setState的同步异步</p><ul><li>合成事件和钩子函数中是“异步”，原生事件和setTimeout中是“同步”</li><li>“异步”并不是内部用异步来实现，而是合成事件和钩子函数的调用顺序在更新之前，导致合成事件和钩子函数拿不到最新的state值</li><li>setState的批量更新优化建立在“异步”（合成事件和钩子函数）中，在原生事件和setTimeout中不会批量更新。批量更新策略中若对同一个值进行多次setState会进行覆盖，取最后一次执行，若进行多次不同值的setState则会合并。</li></ul></li><li><p>HOC高阶组件</p><ul><li><p>包装组件的高阶组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello, world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...this.state</span>&#125;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承组件的高阶组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello, world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>webpack</p><ul><li><p>webpack作用</p><p>分析项目结构，处理模块依赖进行模块打包，转换成浏览器可运行的代码。</p><ul><li>代码转换：typescript转为JavaScript，less、scss转css</li><li>文件优化：压缩js、html、css代码</li><li>代码分割</li><li>模块合并</li><li>自动刷新</li></ul></li><li><p>loader和plugin</p><ul><li>loader用于编译、处理文件，loader的使用配置在modules中，可以有多个loader</li><li>plugin扩展webpack的功能，针对的是loader处理后的webpack整个处理过程。plugin并不知节操作文件，而基于事件机制，监听webpack打包过程中某些节点执行任务。plugin配置在plugin中。plugin一般来说是一个构造器，放入构造的实例即可</li></ul><p><strong>loader是文件转换器，plugin是扩展器</strong>。</p></li><li><p>loader执行顺序</p><p>loader放在数组中时，从有到左执行</p></li><li><p>编写一个loader和plugin</p><ul><li><p>loader模块需要导出为一个模块，函数接收上一个处理结果或资源文件（source file），然后需要返回一个处理结果</p><p>接收的唯一一个参数为资源文件。</p><p>loader模块函数可以分为同步和异步。</p><figure class="highlight javascript"><figcaption><span>一个最简单的loader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">&#x27;aaa&#x27;</span>, <span class="built_in">this</span>.query.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>- plugin  具有`apply`方法的原型的的构造函数，基本结构是  - 一个构造函数  - 原型上定义apply方法  - 绑定到webpack自身的钩子函数中  - 处理webpack内部实例的特定数据  - 完成后调用webpack提供的回调  <figure class="highlight javascript"><figcaption><span>plugin模式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 JavaScript 命名函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyExampleWebpackPlugin</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在插件函数的 prototype 上定义一个 `apply` 方法。</span></span><br><span class="line">MyExampleWebpackPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 指定一个挂载到 webpack 自身的事件钩子。</span></span><br><span class="line">  compiler.plugin(<span class="string">&#x27;webpacksEventHook&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation <span class="comment">/* 处理 webpack 内部实例的特定数据。*/</span>, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is an example plugin!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能完成后调用 webpack 提供的回调。</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><ul><li>webpack分包加载</li></ul><ul><li><p>tree shaking：剔除未被引用代码</p><p>tree shaking基于ES6的import实现，依赖于ES6的模块特性</p><ul><li><p>ES6 module特性：</p><ul><li>只能作为顶层语句出现</li><li>import 的模块名只能是字符串常量</li><li>import binding 是不变的</li></ul><blockquote><p>ES6 的模块依赖关系是确定的，和运行时状态无关，可以进行可靠的静态分析，这就是 tree shaking 的基础。</p></blockquote></li><li><p>tree shaking需要注意的地方：</p><ul><li><p>tree shaking不会清除IIFE（立即调用函数）</p><p>IIFE在解析时才会执行，webpack不会进行程序流分析，不知道IIFE内部执行什么操作，故不会清除IIFE。如果IIFE执行得到的结果没有被引用，依然会被清除。</p></li><li><p>webpack的 production 模式下自动开启 tree shaking</p></li><li><p>babel的问题：babel会对ES6模块进行转译，将 <code>export</code>结合<code>require</code>的形式，致使 tree shaking失效，我们需要对babel处理，不对模块进行进行处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// babel.rc</span></span><br><span class="line">presets: [[</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: &#123;<span class="attr">module</span>: fasle&#125;</span><br><span class="line">]]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>  - webpack tree shaking对第三方的使用    - lodash      <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span> <span class="comment">// &lt;-这种引入方式会全量打包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> map <span class="keyword">from</span> <span class="string">&#x27;lodash/map&#x27;</span> <span class="comment">// &lt;- 这种引入方式按需打包</span></span><br></pre></td></tr></table></figure>- css tree shaking- js tree shaking</code></pre><ul><li><p>多入口/出口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  entry1: <span class="string">&#x27;../src/entry1.js&#x27;</span>,</span><br><span class="line">  entry2: <span class="string">&#x27;../src/entry2.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output: &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>hmr</p></li><li><p>dev server</p></li><li><p>优化</p><ul><li><p>打包速度：</p><ul><li>DllPlugin：将特定的类库提前打包后引入，减少类库打包次数，只有类库版本更新后才需要重新打包，并且实现将公共代码抽离的目的</li><li>优化loader：<code>exclude</code>和<code>include</code>限定，优化搜索范围</li><li>HappPack：采用多线程打包</li></ul></li><li><p>打包体积（加快下载速度</p><ul><li>按需加载：</li><li>spa项目实现按需加载，大型类库的按需加载（antd、lodash）</li><li>Tree shaking：删除代码中未被引用的代码</li><li>代码压缩：<code>UglifyJS</code></li></ul></li></ul><blockquote><p>但是，webpack4开始，很多优化就已经默认开启，不需要去特定配置。</p></blockquote></li><li><p>project</p></li><li><p>虚拟列表实现（长数据列表的渲染优化）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
