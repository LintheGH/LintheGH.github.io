<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图片懒加载</title>
      <link href="2021/02/03/Code-Frontend-javascript-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>2021/02/03/Code-Frontend-javascript-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>图片懒加载是前端比较普遍和使用广泛的用于优化性能的手段。基本原理是用户滚动页面到该图片之后才加载真实图片资源，达到延迟加载，减少不必要的资源浪费和性能损失。在这里记录下网上的，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>getBoundingClientRect</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API"><code>IntersectionObserver</code></a>，两种实现图片懒加载的方法。</p><a id="more"></a><h3 id="使用getBoundingClientRect获取视窗和图片的相对位置判断需要是否需要加载图片"><a href="#使用getBoundingClientRect获取视窗和图片的相对位置判断需要是否需要加载图片" class="headerlink" title="使用getBoundingClientRect获取视窗和图片的相对位置判断需要是否需要加载图片"></a>使用<code>getBoundingClientRect</code>获取视窗和图片的相对位置判断需要是否需要加载图片</h3><ul><li><p><code>getBoundingClientRect</code></p><p><code>Element.getBoundingClientRect()</code>方法返回元素的大小及其相对于视窗的位置。返回<code>DOMRect</code>对象。如果是标准盒模型，元素的尺寸等于<code>width/height</code> + <code>padding</code> + ‘border-width’；如果是<code>border-box</code>盒模型，元素的尺寸等于<code>width/height</code></p></li><li><p><code>DOMRect</code>对象</p><p><code>getBoundingClientRect</code>返回的矩形集合，包括<code>width</code>、<code>height</code>、<code>x</code>、<code>y</code>、<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这几个已像素为单位的只读属性。除<code>widht</code>和<code>height</code>属性以外，其余属性的计算都是由左上角开始。</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnafs48084j30dw0dwt94.jpg" style="zoom:50%;" /></li><li><p>实现</p><figure class="highlight html"><figcaption><span>getBoundingClientRect 图片懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.image-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>getBoundingClientRect 图片懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urlList = [</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=727460147,2222092211&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=2511982910,2454873241&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=825057118,3516313570&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3435942975,1552946865&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3569419905,626536365&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3779234486,1094031034&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=2763645735,2016465681&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3911840071,2534614245&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=3908717,2002330211&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=318887420,2894941323&amp;fm=193&amp;f=GIF&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https://t7.baidu.com/it/u=1063451194,1129125124&amp;fm=193&amp;f=GIF&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendImage</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nodes = urlList.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;img src=&quot;javascript:;&quot; class=&quot;image-item placeholder&quot; data-img=&quot;<span class="subst">$&#123;item&#125;</span>&quot;/&gt;`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  target.innerHTML = nodes.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;box&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.image-item[data-img]&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> boxTop = box.getBoundingClientRect().top</span><br><span class="line">  <span class="keyword">const</span> boxBottom = box.getBoundingClientRect().bottom</span><br><span class="line">  <span class="keyword">const</span> boxHeight = box.getBoundingClientRect().height</span><br><span class="line">  imgList.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> imgHeight = img.offsetHeight</span><br><span class="line">    <span class="keyword">let</span> imgTop = img.getBoundingClientRect().top</span><br><span class="line">    <span class="keyword">let</span> imgBottom = img.getBoundingClientRect().bottom</span><br><span class="line">    <span class="keyword">let</span> imgSrc = img.dataset.img</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(imgBottom&gt;=boxTop &amp;&amp; imgTop &lt; boxBottom) &#123;</span><br><span class="line">      img.setAttribute(<span class="string">&#x27;src&#x27;</span>, imgSrc)</span><br><span class="line">      img.classList.remove(<span class="string">&#x27;placeholder&#x27;</span>)</span><br><span class="line">      img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        img.removeAttribute(<span class="string">&#x27;data-img&#x27;</span>) <span class="comment">// 加载真实图片后删除属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boxScroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  lazyLoad(box)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">appendImage(box);</span><br><span class="line">lazyLoad(box); <span class="comment">// 初始化时需要调用一次</span></span><br><span class="line">box.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, boxScroll);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以用函数节流优化滚动事件的执行次数</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ function throttle(fun, duration) &#123;</span></span><br><span class="line"><span class="addition">+ let preTime = 0</span></span><br><span class="line"><span class="addition">+ return function() &#123;</span></span><br><span class="line"><span class="addition">+ const now = Date.now()</span></span><br><span class="line"><span class="addition">+ const gapTime = now - preTime</span></span><br><span class="line"><span class="addition">+ const ags = arguments</span></span><br><span class="line"><span class="addition">+ if(gapTime &gt; duration) &#123;</span></span><br><span class="line"><span class="addition">+preTime = now</span></span><br><span class="line"><span class="addition">+fun&amp;&amp;fun.apply(this, ags)</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="deletion">- box.addEventListener(&#x27;scroll&#x27;, boxScroll);</span></span><br><span class="line"><span class="addition">+ box.addEventListener(&#x27;scroll&#x27;, throttle(boxScroll, 500));</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-IntersectionObserver-实现图片懒加载"><a href="#使用-IntersectionObserver-实现图片懒加载" class="headerlink" title="使用 IntersectionObserver 实现图片懒加载"></a>使用 <code>IntersectionObserver</code> 实现图片懒加载</h3><ul><li><p><code>IntersectionObserver</code>    </p><p>异步检测目标元素与根元素相交情况变化的方法</p><p>通常会在以下情况中使用到此方法</p><ul><li>图片懒加载——当图片滚动到可见时才进行加载</li><li>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li><li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li><li>在用户看见某个区域时执行任务或播放动画</li></ul><p>用例：</p><figure class="highlight javascript"><figcaption><span>IntersectionObserver</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> option = &#123;</span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#scroll-area&#x27;</span>),</span><br><span class="line">  rootMargin: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">  threshold: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(callBack, option); <span class="comment">// 当满足情况/初始化下，会执行 callBack</span></span><br><span class="line"><span class="keyword">let</span> target = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#listItem&#x27;</span>);</span><br><span class="line">observer.observe(target); <span class="comment">// 监听目标</span></span><br></pre></td></tr></table></figure><ul><li><p>option</p><ul><li><p>root：根元素，用于指定目标的可见性。必须是目标元素的<strong>父级元素</strong>。如果未指定或者为<code>null</code>，则默认为浏览器视窗。</p></li><li><p>rootMargin：根元素的计算交集的区域范围，与css的margin类似’10px 20px 30px 40px’；</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnagqu2a5sj30jq0fgglj.jpg" style="zoom:50%;" /></li><li><p>threshold：单一的number或number数组。target元素和root元素相交程度达到该值的时候IntersectionObserver注册的回调函数将会被执行。如果你只是想要探测当target元素的在root元素中的可见性超过50%的时候，你可以指定该属性值为0.5。如果你想要target元素在root元素的可见程度每多25%就执行一次回调，那么你可以指定一个数组[0, 0.25, 0.5, 0.75, 1]。默认值是0(意味着只要有一个target像素出现在root元素中，回调函数将会被执行)。该值为1.0含义是当target完全出现在root元素中时候 回调才会被执行。</p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnahoj8at4j30jq0g3dfs.jpg" style="zoom:50%;" /><blockquote><p>只有当相交条件满足的时候才会执行callback获取到对象，大于或小于都不执行</p></blockquote></li><li><p>callback：每当目标满足该IntersectionObserver指定的threshold值，回调被调用。回调接收观察者的列表和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserver</code></a> 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback =<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Each entry describes an intersection change for one observed</span></span><br><span class="line">    <span class="comment">// target element:</span></span><br><span class="line">    <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">    <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">    <span class="comment">//   entry.isIntersecting</span></span><br><span class="line">    <span class="comment">//   entry.rootBounds</span></span><br><span class="line">    <span class="comment">//   entry.target</span></span><br><span class="line">    <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserver</code></a> 对象</p><p>当一个<code>IntersectionObserver</code>对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦IntersectionObserver被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。</p><ul><li>属性：<ul><li><code>IntersectionObserver.root</code></li><li><code>IntersectionObserver.rootMargin</code></li><li><code>IntersectionObserver.thresholds</code></li></ul></li><li>方法<ul><li><code>IntersectionObserver.disconnect()</code>：使<code>IntersectionObserver</code>对象停止监听工作。</li><li><code>IntersectionObserver.observe()</code>：使<code>IntersectionObserver</code>开始监听一个目标元素。</li><li><code>IntersectionObserver.takeRecords()</code>：返回所有观察目标的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserverEntry</code></a>对象数组。</li><li><code>IntersectionObserver.unobserve()</code>：使<code>IntersectionObserver</code>停止监听特定目标元素。</li></ul></li></ul></li></ul></li><li><p>实现</p><figure class="highlight javascript"><figcaption><span>IntersectionObserver 图片懒加载</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadObs</span>(<span class="params">option=&#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> defaultOption = &#123;</span><br><span class="line">    root: <span class="literal">null</span>,</span><br><span class="line">    rootMargin: <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">    threshold: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> imgUrl = img.getAttribute(<span class="string">&#x27;data-img&#x27;</span>)</span><br><span class="line">    img.setAttribute(<span class="string">&#x27;src&#x27;</span>, imgUrl)</span><br><span class="line">    img.classList.remove(<span class="string">&#x27;placeholder&#x27;</span>)</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      img.removeAttribute(<span class="string">&#x27;data-img&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="keyword">function</span>(<span class="params">IntersectionObserverEntry, observer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntersectionObserverEntry.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(img.isIntersecting) &#123; <span class="comment">// 满足相交条件</span></span><br><span class="line">        loadImage(img.target)</span><br><span class="line">        observer.unobserve(img.target) <span class="comment">// 取消监听</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;, <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOption, option))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> imgList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.image-item[data-img]&#x27;</span>)</span><br><span class="line">  imgList.forEach(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    observer.observe(img)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听执行</span></span><br><span class="line">lazyLoadObs(&#123;</span><br><span class="line">  root: box,</span><br><span class="line">  rootMargin: <span class="string">&#x27;0px 0px -50px 0px&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>IntersectionObserver</code>兼容性较差</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个记录</title>
      <link href="2020/12/11/%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95/"/>
      <url>2020/12/11/%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的EventLoop</title>
      <link href="2020/12/09/Code-Frontend-javascript-EventLoop/"/>
      <url>2020/12/09/Code-Frontend-javascript-EventLoop/</url>
      
        <content type="html"><![CDATA[<p>js通过事件队列实现异步调用，而事件队列就是 EventLoop 中的相关概念。本文简单说明 EventLoop 的过程</p><a id="more"></a><h2 id="JavaScript-的-Task和MicroTask"><a href="#JavaScript-的-Task和MicroTask" class="headerlink" title="JavaScript 的 Task和MicroTask"></a>JavaScript 的 <code>Task</code>和<code>MicroTask</code></h2><p>  在JavaScript中任务分 宏任务（MacroTask）也叫 Task ，和微任务（MicroTask）</p><ul><li><p>Task:</p><ul><li>JavaScript的所有代码</li><li>setTimeout</li><li>setInterval</li><li>I/O</li><li>UI Rendering</li></ul></li><li><p>MicroTask</p><ul><li>Process.nextTick（Node独有）</li><li>Promise</li><li>MutationObserver<a href="https://javascript.ruanyifeng.com/dom/mutationobserver.html">查看</a></li><li>Object.observe(废弃)</li></ul><blockquote><p>宿主环境提供的为宏任务，如setTimeout;语言标准提供的为微任务，如Promise；以此为记忆标准</p></blockquote></li></ul><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><p>  JavaScript 中有 <code>main thread</code>（主线程） 和 <code>call-stack</code>（调用栈）， 所有的任务都会被放入调用栈等待调用</p><h3 id="thread线程"><a href="#thread线程" class="headerlink" title="thread线程"></a><code>thread</code>线程</h3><ul><li><p>cpu、进程、线程</p><p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。 进程之间相互独立，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 CPU使用时间片轮转进度算法来实现同时运行多个进程。</p><p>线程就好比车间里的工人，一个进程可以包括多个线程，多个线程共享进程资源。</p><blockquote><p><code>进程</code>是cpu资源分配的最小单位</p></blockquote><blockquote><p><code>线程</code>是cpu调度的最小单位</p></blockquote><blockquote><p>不同线程可通信（代价较大</p></blockquote><blockquote><p><code>单线程</code>和<code>多线程</code>，是指在一个进程中的线程数</p></blockquote></li><li><p>javascript是单线程的，通过异步避免阻塞</p><h3 id="JavaScript-调用栈"><a href="#JavaScript-调用栈" class="headerlink" title="JavaScript 调用栈"></a>JavaScript 调用栈</h3><p>调用栈采用的是后进先出<code>LIFO</code>(Last In First Out)的规则， 当函数执行的时候，会创建一个执行上下文添加到栈的最顶端，当执行栈执行完后从栈移出，直到整个栈被清空</p><blockquote><p>调用栈空间是有限的，当调用栈中存有过多的函数而且没有释放时，就会出现爆栈<code>Maximum call stack size exceeded</code>的报错</p></blockquote><figure class="highlight javascript"><figcaption><span>调用栈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run first function&#x27;</span>);</span><br><span class="line">  second()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run first function again&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run second function&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">first() </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global&#x27;</span>);</span><br></pre></td></tr></table></figure><p>整个输出的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">run first function</span><br><span class="line">run second function</span><br><span class="line">run first function again</span><br><span class="line">global</span><br></pre></td></tr></table></figure><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>JavaScript的单线程任务分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程<strong>依次执行</strong>，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待<strong>主线程空闲的时候（调用栈被清空）</strong>，被读取到栈内等待主线程执行。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesx63fjicg311y0ryqv9.gif" alt="event-loop"></p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当点击 <code>inner</code> 时，会发生什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.outer&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.inner&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mutate&#x27;</span>)</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  outer.setAttribute(<span class="string">&#x27;data-random&#x27;</span>, <span class="built_in">Math</span>.random())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick)</span><br><span class="line">inner.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesxwqwuq6g311y0rye87.gif" alt="event-loop"></p><blockquote><p>这里冒泡阶段还是属于 inner 的 click 的处理，虽然调用栈 Stack 清空，这个 Task 并没有完成</p></blockquote></li></ul><h4 id="进阶2"><a href="#进阶2" class="headerlink" title="进阶2"></a>进阶2</h4><p>  当执行 <code>inner.click()</code> 会发生什么</p><p>  输出</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">click</span><br><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">promise</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gesxdkerzlg311y0ryqva.gif" alt="event-loop"></p><blockquote><p>当第一次 <code>click</code> 执行完后，调用栈 <code>Stack </code>并没有清除，此时不能执行微任务 <code>MicroTask</code></p></blockquote><blockquote><p><code>MutationObserver</code> 并没有执行两此，因为上次的执行还在 <code>pending</code> 状态中</p></blockquote><h4 id="进阶3"><a href="#进阶3" class="headerlink" title="进阶3"></a>进阶3</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>  输出<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async2 end</span><br><span class="line">Promise</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p><blockquote><p>以上结果为chrome 73以上版本输出内容，73以下输出结果不一致</p></blockquote><h3 id="async-await和event-loop"><a href="#async-await和event-loop" class="headerlink" title="async await和event-loop"></a><code>async await</code>和<code>event-loop</code></h3><p>  简单了解<code>async await</code>到底干了什么        </p><ul><li><p><code>async</code></p><p><strong>一句话概括： 带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</strong></p><ul><li>如果 <code>async</code> 关键不是返回<code>primise</code>，会自动用<code>Promise.resolve()</code>包裹</li><li>如果<code>async</code>关键字函数显示地返回<code>promise</code>，就以函数返回的<code>promise</code>为准</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn1()) <span class="comment">// Promise &#123;&lt;resolved&gt;: 123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(fn2()) <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>await</code></p><p><strong>一句话概括： await等的是右侧「表达式」的结果</strong></p><ul><li>如果右侧是函数，那么函数的<code>return</code>值就是整个<code>await</code>表达式的结果</li><li>如果右侧是表达式，那么整个<code>await</code>就是这个表达式的结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> fn2()</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这里<code>await</code>等待的结果，会根据是否是<code>promise</code>对象而有不同的处理</p><ul><li><p><code>promise</code>对象</p><p>阻塞后面的代码，跳出<code>async</code>中的代码，执行外面的同步代码。完成后回到<code>async</code>内部，再把这个结果，作为<code>await</code>表达式的结果</p></li><li><p>非<code>promise</code>对象</p><p>阻塞后面的代码，跳出<code>async</code>中的代码，执行外面的同步代码。完成后回到<code>async</code>内部，等待<code>promise</code>对象<code>fulfilled</code>,然后把<code>resolve</code>的结果最为<code>await</code>表达式的 结果</p><blockquote><p>从这部分说， <code>await</code>达式的运行，是从右边到左，先执行<code>await</code>后面的表达式，而并非直接跳出<code>async</code>函数</p></blockquote></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react Hooks</title>
      <link href="2020/01/01/Code-Frontend-react-Hooks/"/>
      <url>2020/01/01/Code-Frontend-react-Hooks/</url>
      
        <content type="html"><![CDATA[<p>React Hooks 使用简单介绍</p><a id="more"></a><h3 id="react-Hooks"><a href="#react-Hooks" class="headerlink" title="react Hooks"></a>react Hooks</h3><hr><h4 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h4><ul><li><code>useState</code></li><li><code>useEffect</code></li><li><code>useLayoutEffect</code></li><li><code>useCallBack</code></li><li><code>useReducer</code></li><li><code>useRef</code></li><li><code>useMemo</code></li></ul><figure class="highlight javascript"><figcaption><span>简单用例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 更新文档的标题</span></span><br><span class="line">            <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>useState</code>:声明和改变组件状态。返回值是一个包含state和改变该state的函数的数组</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><p>参数： 函数接收的参数是一个初始值，初始值的类型不限，可以是<code>array</code>,<code>object</code>…</p></li><li><p>返回： 函数返回一个长度为2的数组，</p><ul><li><p>第一个值<code>useState(0)[0]</code>是组件的初始state，在这里即是<code>0</code></p><blockquote><p>react 会在每次组件渲染后保存这个状态，也就是说<code>useState</code>每次只会在组件首次渲染时执行(组件卸载后再加载初始赋值)</p></blockquote></li><li><p>第二个值<code>useState(0)[1]</code>是改变状态state的方法</p><ul><li><code>setCount</code>是改变组件状态的方法<ul><li>参数：接收的参数即是改变后的<code>状态</code>，接收后react会直接覆盖上一次的state<ul><li><code>function</code>参数：当传入<code>useState(0)[0]</code>的参数是一个函数，<strong>这个函数可以接收一个<code>previousState</code></strong>,返回值作为新的<code>state</code>值  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(&#123;<span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;)</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(<span class="function">(<span class="params">preState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 要达到合并更新的效果，则需要使用...展开运算</span></span><br><span class="line">            ...preState,</span><br><span class="line">            age: <span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        cleanup</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;, [input]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>useState和class 的setState 不同，不会自动合并更新，需要手动合并</p></blockquote></li></ul></li><li>返回：viod</li></ul></li></ul></li><li><p>可以多次使用<code>useState</code></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [fruit, setFruit] =  useState(<span class="string">&#x27;banana)</span></span><br><span class="line"><span class="string">    const [todos, setTodo] = useState([&#123;text: &#x27;</span><span class="keyword">do</span> someting<span class="string">&#x27;&#125;])</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>useEffect</code> 副作用钩子</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似于componentDidMount 和 componentDidUpdate:</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 更新文档的标题</span></span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>useEffect</code>副作用钩子会在每次组件更新之后执行（包括第一次）</p></li><li><p><code>useEffect</code>中解绑一些副作用（如事件监听）：<code>useEffect</code>通过返回一个函数来解绑副作用</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">        </span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">                setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">            useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">                <span class="comment">// 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup</span></span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">                &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;Loading...&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>useEffect</code> 中的解绑会在每次组件更新/卸载后，在<code>useEffect</code>中的操作执行前执行，组件卸载只会执行副作用的解绑函数，可以做一些事件的取消监听</p></blockquote></li></ul></li></ul><blockquote><p><code>useEffect</code> 是一个异步的函数，不会阻塞页面更新</p></blockquote><blockquote><p><code>useLayoutEffect</code> 是一个<code>useEffect</code>的同步版本函数，其使用方法和<code>useEffect</code>一样</p></blockquote><ul><li>跳过一些不必要的副作用<br>通过给 <code>useEffect</code>传入第二个参数，当第二个参数改变时才执行副作用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 只有当count的值发生变化时，才会重新执行document.title这一句</span></span><br></pre></td></tr></table></figure><blockquote><p><code>useEffect</code>在每次执行前，会清除上一次的<code>useEffect</code>，以防止内存泄漏</p></blockquote><ul><li><p><code>useCallBack</code>：<code>useCallBack</code>用于生成一个回调函数，一般用于重复代码抽离</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> calcCount = useCallBack(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count+count2</span><br><span class="line">    &#125;,[count, count2])</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = calcCount()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sum---&#x27;</span>, sum)</span><br><span class="line">    &#125;,[calcCount])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;div className=&#123;<span class="string">&#x27;box&#x27;</span>&#125;&gt;</span><br><span class="line">        &#123;count&#125;&#123;count2&#125;&lt;Button onClick=&#123;setCount(count + <span class="number">1</span>)&#125;&gt;-&lt;<span class="regexp">/Button&gt;&lt;Button onClick=&#123;setCount2(count2+1)&#125;&gt;+&lt;/</span>Button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>useCallBack</code>的使用和<code>useEffect</code>相同，不过useCallBack生成一个回调函数。在第二个参数（数组）中的任一值改变时，会重新生成一个回调函数，在<code>useEffect</code>中的第二个参数监听这个生成的回调函数即可做进一步的操作</p></li><li><p><code>useReducer</code>: <code>useState</code>的替代方案，当组件中的<code>state</code>较多时，可以使用<code>useReducer</code>作为替代。钩子函数接受一个 <code>reducer</code>、一个初始的state<code>initialState</code>和一个处理初始state的处理函数<code>initState</code>，返回值是当前的state和配套的dispatch函数。用法十分类似<code>redux</code>。</p>  <figure class="highlight javascript"><figcaption><span>useReducer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始state</span></span><br><span class="line"><span class="keyword">const</span> initialCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理初始state的函数，可以把state初始化的一些操作放在函数内部</span></span><br><span class="line"><span class="keyword">const</span> initState = <span class="function">(<span class="params">initialCount</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略模式actions</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    add: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    subtract: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...state,</span><br><span class="line">            count: state.count - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer函数，类似redux的reducer，接受state，和action，返回一个新的state</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, payload&#125; = action</span><br><span class="line">    <span class="keyword">const</span> act = actions[type]</span><br><span class="line"><span class="keyword">const</span> newState = act&amp;&amp;act(state, payload) || state</span><br><span class="line">    <span class="keyword">return</span> newState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, initState)</span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">            payload: <span class="string">&#x27;add action&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subtract = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;subtract&#x27;</span>,</span><br><span class="line">            payload: <span class="string">&#x27;subtract action&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;state.count&#125; <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span>++<span class="tag">&lt;/<span class="name">Button</span>&gt;</span><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;subtract&#125;</span>&gt;</span>--<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>useRef</code>：生成一个可变的ref对象，对象中的<code>.current</code>被初始化为传入初始的值，ref对象在整个组件的生命周期中不会自动改变，基于此，ref对象一个强大的作用在于它能够保存某次state, 用于某些操作.</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState(<span class="string">&#x27;notChange&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> ref = useRef(<span class="literal">null</span>) <span class="comment">// &#123;current: null&#125;</span></span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;current&#125; = ref</span><br><span class="line">        <span class="keyword">if</span>(current) &#123;</span><br><span class="line">            setText(<span class="string">&#x27;currentChanged&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,[ref]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ref.current) &#123; <span class="comment">// 这里在未改变ref之前，count不会改变</span></span><br><span class="line">            setCount(count+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &#123;text&#125;&#123;count&#125;&lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;ref.current = <span class="literal">true</span>&#125;&#125; &gt;改变ref&lt;<span class="regexp">/Button&gt;&lt;Button onClick=&#123;add&#125;&gt;+&lt;/</span>Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当<code>useRef</code>用于组件或者DOM时，<code>ref.current</code>初始值会被赋予此组件或DOM元素。</p><p>改变<code>useRef</code>的值不会引起视图更新</p><p><code>useRef</code>创建的ref对象是不可扩展的</p></blockquote></li></ul><p>​    </p><ul><li><code>useMemo</code>： 接收两个参数，计算函数和函数所依赖的数据数组，返回一个由计算函数返回的‘memorized’值。<code>useMemo</code>用于“缓存”计算函数返回的值（可以是数据或者是组件），当所依赖的数据改变时，才会重新调用计算函数返回新的值。<blockquote><p><code>useMemo</code>的出现主要是为了性能优化。在函数组件中，当状态放生变化时，函数组件中所有通过计算出来的值/引入的组件和没有设置关联的effect中的副作用都会重新计算/挂载，当一个组件不用频繁更新并且开销很大时，就会造成性能浪费。</p><p><code>useMemo</code>的作用范畴类似<code>useEffect</code>，但是，<code>useMemo</code>中的计算都与渲染有关，而<code>useEffect</code>中都计算则是各种副作用，在hooks的使用上要各司其职</p></blockquote></li></ul><figure class="highlight javascript"><figcaption><span>useMemo</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这种写法下，每次改变count2也会输出count2的值</span></span><br><span class="line">  <span class="comment">// const count_ = (()=&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(&#x27;count_&#x27;, count2)</span></span><br><span class="line">  <span class="comment">//   return count*2</span></span><br><span class="line">  <span class="comment">// &#125;)()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这种写法下，只有当count改变，才会输出count2的值，当计算开销很大时，可以提高性能</span></span><br><span class="line">  <span class="keyword">const</span> count_ = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;count_2&#x27;</span>, count2)</span><br><span class="line">    <span class="keyword">return</span> count*<span class="number">2</span></span><br><span class="line">  &#125;,[count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &#123;count_&#125;-&#123;count&#125;-&#123;count2&#125;-&#123;props.count&#125;</span><br><span class="line">    &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;double+&lt;/Button&gt;</span><br><span class="line">  &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount2(count2 + <span class="number">1</span>)&#125;&#125;&gt;+&lt;/Button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> Memo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 每次都更新</span></span><br><span class="line">      <span class="comment">// const child = (() =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//   console.log(&#x27;生成child&#x27;)</span></span><br><span class="line">      <span class="comment">//   return &lt;Demo count=&#123;count&#125; /&gt;</span></span><br><span class="line">      <span class="comment">// &#125;)()</span></span><br><span class="line">    </span><br><span class="line">      <span class="keyword">const</span> child = useMemo(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;生成child&#x27;</span>);<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;/</span>&gt;</span></span>&#125;, [count])</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &#123;child&#125;...&#123;count2&#125;</span><br><span class="line">        &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount(count +<span class="number">1</span> )&#125;&#125;&gt;修改child&lt;/Button&gt;</span><br><span class="line">        &lt;Button onClick=&#123;<span class="function">() =&gt;</span> &#123;setCount2(count2 + <span class="number">1</span>)&#125;&#125;&gt;修改count2&lt;/Button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Hooks 使用的一些规则<ol><li> 只在函数组件的最上层使用 <code>Hooks</code>,不得在循环、判断、函数中使用Hooks,让多次调用的<code>useState``useEffect</code>有一个确定的顺序</li><li> 只在函数组件中使用<code>Hooks</code></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router</title>
      <link href="2020/01/01/Code-Frontend-react-react-route/"/>
      <url>2020/01/01/Code-Frontend-react-react-route/</url>
      
        <content type="html"><![CDATA[<p>react-router介绍</p><a id="more"></a><h4 id="react-路由"><a href="#react-路由" class="headerlink" title="react 路由"></a>react 路由</h4><hr><p>react-router的使用</p><ul><li><p>react-router、react-router-dom、react-router-native的区别</p><ul><li>react-router是路由的核心，react-router-dom 比前者多出了 <code>&lt;link&gt;</code>，<code>&lt;BrowserRouter&gt;</code> 这样的 DOM 类组件</li><li>如果你在开发一个网站，你应该使用<code>react-router-dom</code>，如果你在移动应用的开发环境使用React Native，你应该使用<code>react-router-native</code></li><li>我们这里使用 react-router-dom 即可</li></ul></li><li><p><code>react-router</code>（react-router-dom）的使用</p><ul><li><p>基本的路由结构为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;<span class="comment">// 或者 HashRouter</span></span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>因此，我们首先需要在 SPA 应用最外层包裹上一个 Router，Router 分为两种：BrowserRouter 和 HashRouter</p><ul><li>BrowserRouter:<br>使用了HTML5的history API来记录你的路由历史使用了HTML5的history API来记录你的路由历史</li><li>HashRouter:<br>使用URL<code>(window.location.hash)</code>的hash部分来记录</li></ul></li><li><p>在需要切换路由的时候，使用 <code>&lt;Route&gt;</code> 来作为匹配路由选择</p><ul><li>Route 的一些参数：<ul><li>path：string 路径</li><li>component:componentcomponent 渲染的组件。当访问地址和路由匹配时，对应的 component 将会被渲染，并且传入 match、location、history</li><li>render：func render 函数返回需要渲染的组件</li><li>exact：boolean 为 true 时路径将会精准匹配，’/one’ 的路由将不能匹配 ‘/one/two’</li><li>strict：boolean 对路径末尾斜杠的匹配，为 true 时 ‘/one/‘ 将不能匹配 ‘/one’ 但可以匹配 ‘/one/two’，需要确保路由没有末尾斜杠，那么需要 exact 和 strict 都为 true<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router exact=&#123; <span class="literal">true</span> &#125; path=<span class="string">&quot;/home&quot;</span> component= &#123; AppHome &#125; /&gt; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>&lt;Switch&gt;</code><br>  Switch 只会渲染第一个与当前访问地址匹配的 Router 或者 redirect，有效防止同级路由多次渲染</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/&quot;</span> component= &#123; AppHome &#125; /&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/mine&quot;</span> component= &#123; AppMine &#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"><span class="comment">// 当路径为&#x27;/&#x27;时，只渲染第一个</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;Redirect&gt;</code>：重定向。可以使用 Redirect 组件，添加 from 、to 属性进行重定向跳转</p></li><li><p><code>&lt;Link&gt;</code> 和 <code>&lt;NavLink&gt;</code>：</p><ul><li><code>&lt;Link&gt;</code>：声明式导航<ul><li>to：string 跳转指定路径</li><li>to: Object 带参数跳转到指定路径<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">&#x27;/course&#x27;</span>,</span><br><span class="line">  state: &#123; <span class="attr">price</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure></li><li>replace: boolean 跳转时，是否替换访问历史</li></ul></li><li><code>&lt;NavLink&gt;</code>: <code>&lt;Link&gt;</code> 的特殊版，增加了：<ul><li>activeClassName: String 激活时的类名</li><li>activeStyle: Object 激活时的内联样式</li><li>exact：boolean 是否精准匹配</li><li>strict：bolean 是否匹配最后的斜杠</li><li>isActive：func 激活时执行函数</li></ul></li></ul></li><li><p><code>history</code> 对象通常具有以下属性和方法：</p><ul><li>length: number 浏览历史堆栈中的条目数</li><li>action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP</li><li>location: object 当前访问地址信息组成的对象，具有如下属性：<ul><li><code>pathname</code>: string URL路径</li><li>search: string URL中的查询字符串</li><li>hash: string URL的 hash 片段</li><li>state: string 例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state 只有在 browser 和 memory history 有效。</li><li><code>push(path, [state])</code> 在历史堆栈信息里加入一个新条目。</li><li><code>replace(path, [state])</code> 在历史堆栈信息里替换掉当前的条目</li><li><code>go(n)</code> 将 history 堆栈中的指针向前移动 n。</li><li>goBack() 等同于 go(-1)</li><li>goForward 等同于 go(1)</li><li>block(prompt) 阻止跳转</li></ul></li></ul></li><li><p><code>location</code>:当前的位置，将要去的位置，或是之前所在的位置<br>在以下情境中可以获取 location 对象</p><ul><li>在 Route component 中，以 <code>this.props.location</code> 获取</li><li>在 Route render 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 Route children 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 withRouter 中，以 <code>this.props.location</code> 的方式获取</li></ul></li><li><p>路由传参：</p></li><li><p><code>&lt;withRouter&gt;</code> 根据传入的组件生成一个新的组件（高阶组件），<code>&lt;withRouter&gt;</code> 处理过的组件外面会有 Router ，可以使用 <code>this.props.history</code> 等的属性</p></li><li><p>路由钩子：<br>react-router 没有路由钩子，我们需要根据组件的声明周期做出相应的处理<br>比如，当我们要监听某一个组件的进入和离开，我们利用<code>componentWillMount</code>、<code>componentWillUnmount</code><br>全局路由切换, 我们觉得在App里监听就可以了，因为当路由切换的时候，父级路由组件的location属性中pathname会变化<br>但是App组件虽然是全部路由组件的父级组件，但是它不是一个路由组件，所以App外面没有Route组件，所以App没有location属性，所以，无法坚持属性的变化<br>我们可以李扬withRouter来将App处理一下，就是在他外面包一个Route来实现这一个功能<br>我们发现withRouter他可以在任意组件外面包上Route，也就是说，可以让非路由组件也能使用到路由相关的属性</p></li></ul></li></ul><ul><li><p>react-router 的原生数组对象写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routeConfig = [</span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    component: App,</span><br><span class="line">    indexRoute: &#123; <span class="attr">component</span>: Dashboard &#125;,</span><br><span class="line">    childRoutes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;about&#x27;</span>, <span class="attr">component</span>: About &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;inbox&#x27;</span>,</span><br><span class="line">        component: Inbox,</span><br><span class="line">        childRoutes: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/messages/:id&#x27;</span>, <span class="attr">component</span>: Message &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;messages/:id&#x27;</span>,</span><br><span class="line">            onEnter: <span class="function"><span class="keyword">function</span> (<span class="params">nextState, replaceState</span>) </span>&#123;</span><br><span class="line">            replaceState(<span class="literal">null</span>, <span class="string">&#x27;/messages/&#x27;</span> + nextState.params.id)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">React.render(<span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">routes</span>=<span class="string">&#123;routeConfig&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure></li><li><p>复合式写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">  &#123;&#123;</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      component: App,</span><br><span class="line">      childRoutes: []</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  &#123;&#123;</span><br><span class="line">    path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getComponent</span>(<span class="params">nextState, callback</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">require</span>.ensure([], <span class="function"><span class="params">require</span> =&gt;</span> &#123;</span><br><span class="line">        callback(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">&#x27;src/login&#x27;</span>));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="comment">// component 的按需加载式写法</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure><ul><li><code>require-ensure</code><ul><li>说明: <code>require.ensure</code>在需要的时候才下载依赖的模块，当参数指定的模块都下载下来了（下载下来的模块还没执行），便执行参数指定的回调函数。<code>require.ensure</code>会创建一个chunk，且可以指定该chunk的名称，如果这个chunk名已经存在了，则将本次依赖的模块合并到已经存在的chunk中，最后这个chunk在webpack构建的时候会单独生成一个文件。</li><li>语法:<code>require.ensure(dependencies: String[], callback: function([require]), [chunkName: String])</code><ul><li><code>dependencies</code>: 依赖的模块数组</li><li><code>callback</code>: 回调函数，该函数调用时会传一个require参数</li><li><code>chunkName</code>: 模块名，用于构建时生成文件时命名使用</li></ul></li><li>注意点：<code>requi.ensure</code>的模块只会被下载下来，不会被执行，只有在回调函数使用<code>require(模块名)</code>后，这个模块才会被执行。</li></ul></li></ul></li><li><p>路由的按需加载</p><ul><li>定义加载组件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncComponent</span>(<span class="params">importComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        component: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> importComponent();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        component: component</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> C = <span class="built_in">this</span>.state.component;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> C ? <span class="xml"><span class="tag">&lt;<span class="name">C</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> AsyncComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>路由表中使用加载组件：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Buttons = asyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./button&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>babel 配置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;es2015&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;stage-1&quot;</span>, <span class="comment">// 应用了es7的语法，所以必须有这个配置</span></span><br><span class="line">  <span class="string">&quot;react&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p><code>react-router</code>相关梳理</p><ul><li><p>什么是<code>react-router-dom</code>、<code>react-router</code>、<code>react-router-native</code>？<br>总括来说，<code>react-router</code>是react管理路由的工具的总称，其中包括核心的<code>react-router</code>，专门为web端的dom绑定操作的<code>react-router-dom</code>， 专门为<code>react-native</code>使用的<code>react-router-native</code>，此外还有<code>react-router-config</code>和<code>react-router-redux</code>，在react-router的官方GitHub上可以看到起关系<br><img src="https://github.com/LintheGH/images/tree/master/note/react-router.png" alt="react-router"></p><p>在项目中</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react 小tips</title>
      <link href="2020/01/01/Code-Frontend-react-tips/"/>
      <url>2020/01/01/Code-Frontend-react-tips/</url>
      
        <content type="html"><![CDATA[<p>react 小tips</p><a id="more"></a><h3 id="开发中发现的小技巧-注意事项"><a href="#开发中发现的小技巧-注意事项" class="headerlink" title="开发中发现的小技巧/注意事项"></a>开发中发现的小技巧/注意事项</h3><hr><ul><li><p><code>getDerivedStateFromProps</code> 钩子函数</p><p>  <code>getDerivedStateFromProps</code> 钩子函数存在时，不会执行 <code>componentWillMount</code> 钩子函数， 这个钩子函数在每次 <code>render</code> 执行前都会执行，因此通过<code>getDerivedStateFromProps</code>更新的state中的属性不会在接收属性的组件中通过自身的<code>setState</code>更新，state 中的属性值跟传递过来的属性值保持一致<br>  <code>getDerivedStateFromProps</code>函数接收参数<code>preProps``preState</code>，函数内部不能获取到组件实例本身，故无法获取<code>this</code></p></li><li><p><code>props</code>的传递</p><p>  当我们把父组件的数据传递到子组件时，通常子组件会<code>this.props.xxxx</code>接收</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>id is:&#123;this.props.data.attr.id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        sonData: &#123;</span><br><span class="line">            attr: &#123;</span><br><span class="line">                id: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">data</span>=<span class="string">&#123;this.state.sonData&#125;/</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这时<code>id</code>的值时同步传过来到，子组件在渲染时可以第一时间获取到传过来到值</p><p>  但是当传递当值时父组件通过异步获取到时，子组件在初次渲染时就会获取不到值，从而时页面崩溃<br>  这时需要加上判断</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>id is:&#123;!!this.props.data.attr?this.props.data.attr.id&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        sonData: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                sonData: &#123;</span><br><span class="line">                    attr: &#123;</span><br><span class="line">                        id: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                        name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">data</span>=<span class="string">&#123;this.state.sonData&#125;/</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在一些需要用到父组件数据来是请求数据时，可以在<code>componentUpdate</code>、<code>componentWillReceiveProps</code>(将被删除，不推荐)、<code>getDerivedStateFromProps</code>钩子函数中判断数据是否存在来做进一步操作</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">preProps, preState</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!!<span class="built_in">this</span>.props.attr.id) &#123;</span><br><span class="line">            axios.get(...).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                    age: res.data.age</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;age&#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">            &#123;age&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>key</code>：react中的key是组件的身份标识，每个key对应一个组件，相同key的组件被认为是同一个组件，后续组件不会被创建，如下</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this.state.users内容</span></span><br><span class="line"><span class="built_in">this</span>.state = &#123;</span><br><span class="line">    users: [&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>&#125;],</span><br><span class="line">    ....<span class="comment">//省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;用户列表&lt;/h3&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.users.map(<span class="function"><span class="params">u</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;u.id&#125;</span>&gt;</span>&#123;u.id&#125;:&#123;u.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述组件中的渲染后，用户列表只有<code>章三</code>和<code>李四</code>两个用户，李四和王五的可以相同，被认为是同一个组件</p><p>  react对拥有key属性的组件的处理</p><ul><li><strong>key相同</strong>： 若组件属性有变化，react只更新组件对应的属性，没有变化则不更新</li><li><strong>key不相同</strong>：组件销毁，然后再重新创建一个组件，此时组件的生命周期会重新执行</li></ul></li><li><p>antd 的表单提交的问题</p><p>  antd中的form 表单提交，当按钮用htmlType=”submit” 时，提交的函数必须调用 <code>e.preventDefault</code> 函数阻止默认行为</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react</title>
      <link href="2020/01/01/Code-Frontend-react-react/"/>
      <url>2020/01/01/Code-Frontend-react-react/</url>
      
        <content type="html"><![CDATA[<p>react 介绍</p><a id="more"></a><h1 id="react-轻量级视图层框架"><a href="#react-轻量级视图层框架" class="headerlink" title="react:轻量级视图层框架"></a>react:轻量级视图层框架</h1><h4 id="react-高性能的体现：虚拟-DOM"><a href="#react-高性能的体现：虚拟-DOM" class="headerlink" title="react 高性能的体现：虚拟 DOM"></a>react 高性能的体现：虚拟 DOM</h4><p>  React高性能的原理：</p><p>在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。</p><p>React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A  UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。</p><p>尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，部而对实际DOM进行操作的仅仅是Diff分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。数据驱动，声明式</p><h4 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h4><ul><li><p>虚拟DOM</p><p>我们以前操作dom的方式是通过document.getElementById()的方式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进行操作</p><p>而reactjs定义了一套变量形式的dom模型，一切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的高，和主流MVC框架有本质的区别，并不和dom打交道</p></li><li><p>组件系统</p><p>react最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件 component</p><p>那么什么是组件呢？</p><p>组件指的就是同时包含了html、css、js、image元素的聚合体</p><p>使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式</p></li><li><p>单向数据流</p><p>其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了</p></li><li><p>语法</p><p>在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; React.createElement 函数创建 DOM 结构</span><br><span class="line">React.createElement(&#39;div&#39;, null,</span><br><span class="line">  React.createElement(&#39;h1&#39;, null, &#39;Hello World&#39;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="依赖文件"><a href="#依赖文件" class="headerlink" title="依赖文件"></a>依赖文件</h4></li><li><p>react.js<br>React 对象，有创建组件等功能</p></li><li><p>react-dom<br>ReactDOM 对象，渲染组件的虚拟 DOM 为真实 DOM 的爆发功能</p></li><li><p>编译 JSX 代码</p><ul><li>浏览器端编译，需要引入 browser 文件</li><li>利用 webpack 等开发环境编译</li></ul></li></ul><h4 id="JSX-（javascript-xml）"><a href="#JSX-（javascript-xml）" class="headerlink" title="JSX （javascript xml）"></a>JSX （javascript xml）</h4><p>JSX 借鉴了 xml 的语法，但是因为是 javascript 语法，所以应遵循 js 语法规则（关键字等）</p><h4 id="react-组件"><a href="#react-组件" class="headerlink" title="react 组件"></a>react 组件</h4><ul><li>在react里表达式的符号是 “{  }”,作用和vue的表达式作用是一样的</li><li>为组件添加类名，class需要写成className（因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字）</li><li>为组件绑定事件：事件名字需要写成小驼峰的方式，值利用表达式传入一个函数即可 </li><li>defaultValue</li><li>defaultChecked</li><li>dangerouslySetInnerHtml<br>让标签编译 html 代码，容易受到 XSS 攻击<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function handleClick ()&#123;operation&#125;</span><br><span class="line">render () &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick&#x3D; &#123;this.handleClick&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建组件 组件渲染到 APP 节点时会覆盖里面的内容</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;aaa&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;&#x2F;&#x2F; 设定为 babel 让 browser 编译</span><br><span class="line">  var Hello &#x3D; React.createClass(&#123;&#x2F;&#x2F; 组件名开头必须大写</span><br><span class="line">    render () &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">          &#123;&#x2F;* JSX 里面的注释必须写成这种格式，否则会被编译*&#x2F;&#125;</span><br><span class="line">            &lt;h1&gt;Hello World&lt;&#x2F;h1&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; ReactDOM.render 函数渲染 DOM 的到页面</span><br><span class="line">  ReactDOM.render(&lt;Hello&gt;&lt;&#x2F;Hello&gt;,app)</span><br></pre></td></tr></table></figure></li><li>ref 为组件标记<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p ref = <span class="string">&quot;p&quot;</span>&gt; Hello World &lt;/p&gt;</span><br><span class="line">        &lt;p ref = &#123; <span class="function">(<span class="params">el</span>) =&gt;</span> &#123; <span class="built_in">this</span>.pp = el &#125; &#125;&gt; Hello World &lt;<span class="regexp">/p&gt; /</span><span class="regexp">/ ref 内的函数接收到当前标记的 NODE 返回 this.pp = el，即把当前 NODE 挂载到组件中</span></span><br><span class="line"><span class="regexp">        &lt;button onClick = &#123;this.changeWorldColor&#125;&gt; change &lt;/</span>button&gt;</span><br><span class="line">        &lt;World ref = &#123;<span class="function"><span class="params">world</span> =&gt;</span> <span class="built_in">this</span>.world = world&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount () &#123; <span class="comment">//ref的标记官方推荐使用函数的方式，接收到要做标记的元素或者子组件，将其挂载this上</span></span><br><span class="line">    <span class="built_in">this</span>.refs.p.style.color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.pp.style.color = <span class="string">&#x27;pink&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>map<ul><li>在react中使用map方法来将数据数组转换成盛放虚拟dom结构的数组，利用表达式放入到组件的虚拟dom结构中，在 <code>&#123;&#125;</code> 内的数组会被动态解析<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</span><br><span class="line">  getInitailState () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      fruit: [</span><br><span class="line">        <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;watermelon&#x27;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  renderFruit () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.fruit.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span> = <span class="string">i</span>&gt;</span> &#123; item &#125; ))// 可以根据需要循环出需要的数据</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  render () &#123;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123; this.renderFruit() &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">Hello</span>/&gt;</span>, app)</span></span><br></pre></td></tr></table></figure><h4 id="Props-和-State"><a href="#Props-和-State" class="headerlink" title="Props 和 State"></a>Props 和 State</h4></li></ul></li><li>属性（Props）：在组件外部传入，或者内部设置（getDefaultProps），组件内通过 <code>this.props</code>获取</li><li>状态（state）：由组件设置或更改，内部通过 <code>this.state</code>获取</li><li>getDefaultPorps()</li><li>getInitialState</li><li>setState<br>更改组件的状态 state 会触发重新渲染<br>在setState中传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须返回像上面方式一样的一个对象，函数可以接收prevState和props<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> Father = React.createClass(&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;我是父组件&lt;/p&gt;</span><br><span class="line">          &lt;Son name=&#123;<span class="string">&#x27;tom&#x27;</span>&#125;&gt;&lt;/Son&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">var</span> Son = React.createClass(&#123;</span><br><span class="line">    getDefaultProps () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;jim&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getInitialState () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    changeAge () &#123;</span><br><span class="line">      <span class="comment">// this.state.age++ // 不会触发视图更新</span></span><br><span class="line">      <span class="comment">// this.setState ((previousState, props) =&gt; &#123; // 触发视图更新</span></span><br><span class="line">      <span class="comment">//   return &#123;</span></span><br><span class="line">      <span class="comment">//     age: previousState.age + 1</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        age: <span class="built_in">this</span>.state.age+<span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;我是子组件&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;我的名字是：&#123;<span class="built_in">this</span>.props.name&#125;, 年龄：&#123; <span class="built_in">this</span>.state.age &#125;&lt;<span class="regexp">/p&gt;&#123;/</span>*父组件传入会覆盖初始属性*/&#125;</span><br><span class="line">          &lt;button onClick= &#123; <span class="built_in">this</span>.changeAge &#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Father</span>/&gt;</span></span>,app)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="属性和状态的对比"><a href="#属性和状态的对比" class="headerlink" title="属性和状态的对比"></a>属性和状态的对比</h4></li></ul><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点： </p><ol><li>属性能从父组件获取，状态不能</li><li>属性可以由父组件修改，状态不能</li><li>属性能在内部设置默认值 ，状态也可以</li><li>属性不在组件内部修改   ，状态要改</li><li>属性能设置子组件初始值  ，状态不可以</li><li>属性可以修改子组件的值，状态不可以</li></ol><p>状态只和自己相关，由自己维护</p><p>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p><h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h4><p><img src="https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg" alt="life cycle"></p><ul><li>初始化阶段钩子函数<ul><li>getDefaultPorps () <ul><li>作用：挂载默认属性，当给组件设置属性的时候会覆盖掉（优先级低）</li><li>特点： <ul><li>不管实例化多少次组件，只执行一次，因为组件实例间的默认属性是共享的</li></ul></li></ul></li><li>getInitailState () {}<ul><li>每次实例化组件都会执行，也就是说每一个组件都有一个自己独立的状态</li></ul></li><li>componentWillMount () {}<ul><li>相当与 vue 的 created + beforeMount ，渲染之前最后一次更改数据的机会，更改数据不会触发 render 的重新执行<blockquote><p>react中官方不推荐我们在componentWillMount里这么做，会有安全的问题</p></blockquote></li></ul></li><li>render () {}<ul><li>渲染 DOM </li></ul></li><li>componentDidMount () {}<ul><li>页面中生成真实的 DOM ，可以做 DOM 相关的操作</li></ul></li></ul></li><li>组件运行阶段钩子函数<ul><li>componentWillReceiveProps (nextProps) {}<ul><li>这时得知属性的变化，执行对应操作</li><li>形参 nextProps 是新的数据，而 this.props 和 this.state 仍然为更改前的数据</li></ul></li><li>shouldComponentUpdate (nextProps, nextState) {}<ul><li>componentWillReceiveProps 钩子后执行</li><li>函数返回值为 true 时，组件才更新，false 时不会更新，当代码中书写了这个函数时，默认会返回 false </li><li>接收新的数据 nextProp nextState ，可以根据新数据和原数据对比，控制组件是否更新</li></ul></li><li>componentWillUpdate(nextProps, nextState)<ul><li>组件马上更新，在函数内不要更新状态，否则<strong>死循环</strong></li></ul></li><li>render () {}<ul><li>组件重新渲染</li></ul></li><li>componentDidUpdate (preProps, preState) {}<ul><li>更改完成，页面重新生成 DOM </li></ul></li></ul></li><li>组件销毁阶段<ul><li>componentWillUnmount () {}<br>怎么样就算组件被销毁：<ol><li>当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁</li><li>调用ReactDOM.unmountComponentAtNode(node) 方法来将某节点中的组件销毁</li></ol></li></ul></li></ul><h5 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h5><p>  功能： 更改函数的this指向<br>  es6 -&gt; 全局函数中的this不指向window<br>  call和apply是在调用函数的过程中，将函数的this改掉<br>  bind 更改指针和传参的方式和call一样，但是不能执行函数，而是返回一个新的更改指针并传参后的函数</p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><ul><li><p>父子组件通信</p></li><li><p>非父子组件通信</p><ul><li>状态提升</li></ul></li></ul><h4 id="无状态组件（函数定义组件）"><a href="#无状态组件（函数定义组件）" class="headerlink" title="无状态组件（函数定义组件）"></a>无状态组件（函数定义组件）</h4><p>在使用组件的时候，我们不需要组件拥有自己的状态，只需要接收外界传入的属性之后做出反应（如渲染相应的 DOM 结构）<br>可以利用纯函数的方式将其制作成无状态组件，提高性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 定义无状态组件</span></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick = &#123; props.handler &#125;&gt;pay&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用无状态组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pay</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">component</span> </span>= &#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.props = &#123;</span><br><span class="line">      handler () &#123;</span><br><span class="line">        alert(<span class="string">&#x27;const $110&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button props = &#123;<span class="built_in">this</span>.props&#125; /&gt; <span class="comment">// 传入 this.props</span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="context-传递数据"><a href="#context-传递数据" class="headerlink" title="context 传递数据"></a>context 传递数据</h4><p>组件间的数据传递默认是层层传递，不能跳层。<br>react 提供了context 组件树状态传递方式，可以把数据让某一个外层的父级组件创建一个 context ,然后利用 Context.Provider 传递给所有的子级组件，任意子级组件可以通过 Context.Consumer 来获取这个 context 上的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> </span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 创建一个 theme Context ，默认值为 light</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        &#123; <span class="function"><span class="keyword">function</span> (<span class="params">theme</span>) </span>&#123; <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123; theme &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)&#125; &#125; <span class="comment">// 函数接收 dark 返回渲染出组件</span></span><br><span class="line">      &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;B/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    &lt;ThemeContext.Provider value=<span class="string">&quot;dark&quot;</span>&gt; <span class="comment">// 传入一个 dark</span></span><br><span class="line">      &lt;A/&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ES6-的react"><a href="#ES6-的react" class="headerlink" title="ES6 的react"></a>ES6 的react</h4><p>在新版的 react 中，采用了新的组件创建方式和新的属性、状态设置方式</p><ul><li>组件创建使用 class 来创建</li><li>在 es6 中不再使用 getInitialState 来设置默认属性，而是在 constructor 里直接给 this.state 上挂载数据</li><li>属性设置通过给类设置 defaultProps 属性来设置默认属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span> <span class="title">component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      doing: <span class="string">&#x27;studing&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">App.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">&#x27;App根组件&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="react-路由"><a href="#react-路由" class="headerlink" title="react 路由"></a>react 路由</h4><hr><p>react-router的使用</p><ul><li><p>react-router、react-router-dom、react-router-native的区别</p><ul><li>react-router是路由的核心，react-router-dom 比前者多出了 <code>&lt;link&gt;</code>，<code>&lt;BrowserRouter&gt;</code> 这样的 DOM 类组件</li><li>如果你在开发一个网站，你应该使用<code>react-router-dom</code>，如果你在移动应用的开发环境使用React Native，你应该使用<code>react-router-native</code></li><li>我们这里使用 react-router-dom 即可</li></ul></li><li><p><code>react-router</code>（react-router-dom）的使用</p><ul><li><p>基本的路由结构为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;<span class="comment">// 或者 HashRouter</span></span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>因此，我们首先需要在 SPA 应用最外层包裹上一个 Router，Router 分为两种：BrowserRouter 和 HashRouter</p><ul><li>BrowserRouter:<br>使用了HTML5的history API来记录你的路由历史使用了HTML5的history API来记录你的路由历史</li><li>HashRouter:<br>使用URL<code>(window.location.hash)</code>的hash部分来记录</li></ul></li><li><p>在需要切换路由的时候，使用 <code>&lt;Route&gt;</code> 来作为匹配路由选择</p><ul><li>Route 的一些参数：<ul><li>path：string 路径</li><li>component:componentcomponent 渲染的组件。当访问地址和路由匹配时，对应的 component 将会被渲染，并且传入 match、location、history</li><li>render：func render 函数返回需要渲染的组件</li><li>exact：boolean 为 true 时路径将会精准匹配，’/one’ 的路由将不能匹配 ‘/one/two’</li><li>strict：boolean 对路径末尾斜杠的匹配，为 true 时 ‘/one/‘ 将不能匹配 ‘/one’ 但可以匹配 ‘/one/two’，需要确保路由没有末尾斜杠，那么需要 exact 和 strict 都为 true<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router exact=&#123; <span class="literal">true</span> &#125; path=<span class="string">&quot;/home&quot;</span> component= &#123; AppHome &#125; /&gt; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>&lt;Switch&gt;</code><br>  Switch 只会渲染第一个与当前访问地址匹配的 Router 或者 redirect，有效防止同级路由多次渲染</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/&quot;</span> component= &#123; AppHome &#125; /&gt;</span><br><span class="line">  &lt;Router  path=<span class="string">&quot;/mine&quot;</span> component= &#123; AppMine &#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"><span class="comment">// 当路径为&#x27;/&#x27;时，只渲染第一个</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;Redirect&gt;</code>：重定向。可以使用 Redirect 组件，添加 from 、to 属性进行重定向跳转</p></li><li><p><code>&lt;Link&gt;</code> 和 <code>&lt;NavLink&gt;</code>：</p><ul><li><code>&lt;Link&gt;</code>：声明式导航<ul><li>to：string 跳转指定路径</li><li>to: Object 带参数跳转到指定路径<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123; </span><br><span class="line">  pathname: <span class="string">&#x27;/course&#x27;</span>,</span><br><span class="line">  state: &#123; <span class="attr">price</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure></li><li>replace: boolean 跳转时，是否替换访问历史</li></ul></li><li><code>&lt;NavLink&gt;</code>: <code>&lt;Link&gt;</code> 的特殊版，增加了：<ul><li>activeClassName: String 激活时的类名</li><li>activeStyle: Object 激活时的内联样式</li><li>exact：boolean 是否精准匹配</li><li>strict：bolean 是否匹配最后的斜杠</li><li>isActive：func 激活时执行函数</li></ul></li></ul></li><li><p><code>history</code> 对象通常具有以下属性和方法：</p><ul><li>length: number 浏览历史堆栈中的条目数</li><li>action: string 路由跳转到当前页面执行的动作，分为 PUSH, REPLACE, POP</li><li>location: object 当前访问地址信息组成的对象，具有如下属性：<ul><li><code>pathname</code>: string URL路径</li><li>search: string URL中的查询字符串</li><li>hash: string URL的 hash 片段</li><li>state: string 例如执行 push(path, state) 操作时，location 的 state 将被提供到堆栈信息里，state 只有在 browser 和 memory history 有效。</li><li><code>push(path, [state])</code> 在历史堆栈信息里加入一个新条目。</li><li><code>replace(path, [state])</code> 在历史堆栈信息里替换掉当前的条目</li><li><code>go(n)</code> 将 history 堆栈中的指针向前移动 n。</li><li>goBack() 等同于 go(-1)</li><li>goForward 等同于 go(1)</li><li>block(prompt) 阻止跳转</li></ul></li></ul></li><li><p><code>location</code>:当前的位置，将要去的位置，或是之前所在的位置<br>在以下情境中可以获取 location 对象</p><ul><li>在 Route component 中，以 <code>this.props.location</code> 获取</li><li>在 Route render 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 Route children 中，以 <code>(&#123;location&#125;) =&gt; ()</code> 方式获取</li><li>在 withRouter 中，以 <code>this.props.location</code> 的方式获取</li></ul></li><li><p>路由传参：</p></li><li><p><code>&lt;withRouter&gt;</code> 根据传入的组件生成一个新的组件（高阶组件），<code>&lt;withRouter&gt;</code> 处理过的组件外面会有 Router ，可以使用 <code>this.props.history</code> 等的属性</p></li><li><p>路由钩子：<br>react-router 没有路由钩子，我们需要根据组件的声明周期做出相应的处理<br>比如，当我们要监听某一个组件的进入和离开，我们利用<code>componentWillMount</code>、<code>componentWillUnmount</code><br>全局路由切换, 我们觉得在App里监听就可以了，因为当路由切换的时候，父级路由组件的location属性中pathname会变化<br>但是App组件虽然是全部路由组件的父级组件，但是它不是一个路由组件，所以App外面没有Route组件，所以App没有location属性，所以，无法坚持属性的变化<br>我们可以李扬withRouter来将App处理一下，就是在他外面包一个Route来实现这一个功能<br>我们发现withRouter他可以在任意组件外面包上Route，也就是说，可以让非路由组件也能使用到路由相关的属性</p></li></ul></li></ul><h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>hoc<br>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件</p><h4 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h4><p>在 vue 中可以利用空实例进行非父子之间通信，因为 vue 的实例拥有 <code>$on</code>, <code>$emit</code> 方法，可以绑定事件和触发事件，就可以在一个组件中为实例绑定事件，在另一个实例里为这个空实例触发事件<br>在 react 中，可以引入 node 中的 events 模块中 EventEmitter, 它的原型上有 <code>on</code>， <code>emit</code></p><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><hr><p>redux 是一个架构思想，redux 工具实现这种思想<br>redux 架构是应用系统架构，和 MVC、MVVM 同种概念</p><ul><li><p>redux 的结构： store、reducer、view、actionCreator</p></li><li><p>安装 redux 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux -S</span><br></pre></td></tr></table></figure></li><li><p><code>store</code>： </p><ul><li>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</li><li>创建 store<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)<span class="comment">// 注册时传入一个函数（reducer），在调用 store.dispatch(action) 的时候会自动调用函数（reducer）</span></span><br></pre></td></tr></table></figure>createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。</li></ul></li><li><p>reducer ：</p><ul><li>Store 收到 Action 以后，必须给出一个新的 State（在previousState 中如果存在 Array,Object 等的引用类型的时候需要重新赋予新的引用地址），这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</li><li>reducer 是一个纯函数，接收两个函数：当前的状态（state）、以及action，返回一个新的状态就代表这store中的 state 改变了</li><li>给 reducer 函数中参数 <code>previousState</code> 设置默认值则为 state 设置了默认值<blockquote><p>当 createStore 中传入第二个参数时，表示 state 的最初状态，这个状态会覆盖 reducer 设置的默认 state</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span> <span class="comment">// 设置的默认值</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">previousState = state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> new_state = &#123; ...previousState &#125;</span><br><span class="line">  <span class="keyword">return</span> new_state</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer <span class="comment">// 暴露出去给 createStore </span></span><br></pre></td></tr></table></figure><blockquote><p>纯函数：只要是同样的输入就会得到同样的输出</p><ul><li>不得改写参数</li><li>不能调用系统 I/O 的 API </li><li>不能调用 <code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会输出不确定的结果</li></ul></blockquote></li></ul></li><li><p>使用 store 中的状态</p><p><code>store.getState()</code> 方法可以获得其中管理的 state</p><blockquote><p>state: Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。</p></blockquote></li><li><p>action</p><ul><li>当 view 需要更改状态的时候，创建 action 来生成来生成一个动作</li><li>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。其他属性可以自由设置</li><li>actionCreator： View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actionCreator = &#123;<span class="comment">// 组件调用 actionCreator 选择需要的函数</span></span><br><span class="line">  login (username) &#123;<span class="comment">// 返回一个 action（对象）</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">&#x27;CHANGE_USERINFO&#x27;</span>,</span><br><span class="line">      username</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>store.dispatch()</code> 方法</p><ul><li><code>store.dispatch()</code>是 View 发出 Action 的唯一方法。</li><li><code>store.dispatch()</code> 会自动调用 reducer 生成一个新的 state</li></ul></li><li><p><code>store.subscribe()</code></p><ul><li>组件中想要得知状态改变的化，则需要使用 <code>store.subscribe()</code> 方法来订阅状态变化，传入回调函数，这个函数会在状态变化时执行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState()) <span class="comment">// 当 state 改变时就会输出 state</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。<blockquote><p>只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入listen，就会实现 View 的自动渲染</p></blockquote></li></ul></li><li><p>reducer 划分<br>在 vuex 中可以分模块管理模块，可以更好的协同合作，互不干扰，在 redux 中划分模块，划分 reducer 即可</p><ul><li>reducer 使用 redux 提供的 <code>combineReducers</code> 来划分 reducer<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todolist <span class="keyword">from</span> <span class="string">&#x27;./todolist&#x27;</span></span><br><span class="line"><span class="keyword">import</span> couter <span class="keyword">from</span> <span class="string">&#x27;./couter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todolist,</span><br><span class="line">  couter</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取用 state</span></span><br><span class="line">store.getState().todolist.aaa</span><br><span class="line">store.getState().couter.bbb</span><br></pre></td></tr></table></figure></li></ul></li><li><p>redux 执行流程<br><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt="redux"></p></li></ul><ol><li>用户发出 action  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(action)</span><br></pre></td></tr></table></figure></li><li>store 自动调用 reducer ，接收两个参数，当前 state 和 action，返回一个新的 state <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextState = reducer(previousState, action)</span><br></pre></td></tr></table></figure></li><li>state 变化，store 调用监听函数 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.subscribu(listener)</span><br></pre></td></tr></table></figure></li><li>listener 可以通过 store.getState() 得到新的 state，在 react 中，这时可以触发重新渲染 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newState = store.getState()</span><br><span class="line">  component.setState(newState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="react-redux-工具"><a href="#react-redux-工具" class="headerlink" title="react-redux 工具"></a>react-redux 工具</h4>react-redux 工具提高 redux 操作的简易程度<h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5></li></ol><ul><li><p>react-redux 认为组件分为两种：UI组件（木偶组件），容器组件（智能组件）</p><ul><li><p>父组件 -&gt; 容器组件 =&gt; 负责管理数据和逻辑</p></li><li><p>子组件 -&gt; UI 组件 =&gt; 负责 UI 呈现，不做任何业务逻辑</p></li></ul></li><li><p>安装 react-redux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-redux -S</span><br></pre></td></tr></table></figure><h5 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h5></li><li><p><code>&lt;Provider&gt;</code> 组件<br>使用 react-redux 的时候，在<strong>最外层组件</strong>包裹 Provider 组件，并传入 store </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123; store &#125;&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">, <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Provider 组件作为提供者，为包裹在内的左右容器组件提供 store ，利用 context 树进行传递</li></ul></li><li><p><code>connect()</code> 方法</p><ul><li><p><code>cnnect()</code>函数传入一个组件，返回一个高阶组件</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">let</span> HOC = connect()</span><br><span class="line"><span class="keyword">let</span> HOCcomponent = HOC(UIcomponent)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HOCcomponent</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">exprot <span class="keyword">default</span> connect()(UIcomponent)</span><br></pre></td></tr></table></figure></li><li><p><code>connect()</code>接收两个参数，这两个参数分别为两个函数</p><ul><li><p><code>mapStateToProps()</code></p><ul><li><p><code>mapStateToProps</code>是一个函数。接收 state。建立一个从（外部的）<code>state</code> 对象到（UI 组件的）<code>props</code> 对象的映射关系。执行后返回一个<strong>对象</strong>，里面的每一个键值对就是一个映射。<strong>函数返回什么，props 里就有什么</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = (<span class="function">(<span class="params">state</span>) =&gt;</span> &#123; <span class="comment">// 函数可以接收到 state</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state.todos <span class="comment">// 返回 state 里的 todos UI组件里的 props 会接收到 todos，可以直接使用 this.props.todos 来调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>mapStateToProps</code>会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p></li><li><p>可以接收第二参数，第二个参数代表容器组件的 props 如果容器组件的 props 发生改变也会触发 UI 组件的重新渲染</p></li></ul></li><li><p><code>mapDispatchToProps()</code></p><ul><li><p>建立 UI 组件的参数到<code>store.dispatch</code>方法的映射。作为函数时会接收 store的 dispatch 方法，返回值是对象，键值对对应 props 接收方法；如果是对象，每个健名对应一个方法名，键值（函数）会被当做一个actionCreator，返回的 action 会有 redux 自动发出。一般以函数的形式直接返回函数，函数内直接 dispatch.<strong>函数返回什么，props就有什么</strong></p></li><li><p>同样第二个参数为容器组件的 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="function"><span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addTodo (todo) &#123;</span><br><span class="line">      disptach(&#123;</span><br><span class="line">        type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">        todo</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UI 组件直接调用 addTodo 方法即可完成 disptch</span></span><br><span class="line"><span class="built_in">this</span>.props.addTodo(<span class="string">&#x27;doSomething&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>bindActionCreator</code> 方法</p><p>bindActionCreator 方法是 redux 提供的方法，可以将 actionCreator 中的action 集合分别 dispatch ，返回值是一个对象，props 接收这个对象中的键值对</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreator &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> actionCreator <span class="keyword">from</span> <span class="string">&#x27;../store/actionCreator.js&#x27;</span> <span class="comment">// 自己穿件的actionCreator</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps (dispatch) &#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreator(actionCreator, dispatch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 actionCreator 的集合 为 &#123; addtodo:&#123; type: &#x27;addtodo&#x27; &#125;, add: &#123; type: &#x27;add&#x27; &#125; &#125; ，则在 UI 组件 props 中可以这样调用</span></span><br><span class="line"><span class="built_in">this</span>.props.addtodo()</span><br><span class="line"><span class="built_in">this</span>.props.add()</span><br></pre></td></tr></table></figure><h4 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h4><p>redux 的执行过程中，action 发出后立即执行 reducer 生成state，这时一个同步的过程，那么当我们要执行异步操作会如何呢？</p></li></ul></li></ul></li></ul></li></ul><p>如果我们想要先去经过一个异步操作，再去返回action怎么办，异步逻辑不能写在视图层的组件中，依然需要写在actionCreator中，但是如果有异步操作的话，我们就无法返回action</p><p>这个时候我们就需要使用一些redux的中间件工具：redux-thunk、redux-promise、redux-saga</p><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">参考文档</a></p><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><ul><li><p>中间件的概念：<br>站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p><ol><li>Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</li><li>View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</li><li>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li></ol><p>想来想去，只有发送 Action 的这个步骤，即store.dispatch()方法，可以添加功能。举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对store.dispatch进行如下改造。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dispatching&#x27;</span>, action);</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;next state&#x27;</span>, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对<code>store.dispatch</code>进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。</p><ul><li>中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</li></ul></li><li><p>中间件的用法</p><ul><li><p>配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));<span class="comment">// 当createStore传入第二个参数作为state初始值时，applyMiddleware就是第三个参数</span></span><br></pre></td></tr></table></figure></li><li><p>中间件的顺序有要求，否则不会出正确结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk, promise, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>applyMiddleware()</code></p><p>Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。</p></li></ul></li></ul><ul><li>配置好之后，<code>actionCreator</code>方法的返回值可以是一个函数，这个函数会接受dispatch，在这个方法中我们可以执行异步操作然后直接 dispatch 一个 action<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actionCreator  = &#123;</span><br><span class="line">    <span class="comment">// addNewTodo (title) &#123;// 同步方法直接返回action</span></span><br><span class="line">    <span class="comment">//     let action = &#123; type: ADD_NEW_TODO, title &#125;</span></span><br><span class="line">    <span class="comment">//     return action             </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    addNewTodo (title) &#123;<span class="comment">// 异步方法</span></span><br><span class="line">        <span class="comment">//可以直接返回一个接受dispatch的函数，这样的话我们就可以将异步创建的action直接dispatch</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">            backend.saveTitle(title).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> action = &#123; <span class="attr">type</span>: ADD_NEW_TODO, title &#125;</span><br><span class="line">                dispatch(action)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="react-组件库"><a href="#react-组件库" class="headerlink" title="react 组件库"></a>react 组件库</h4></li><li>ant-design </li><li>ant-mobile</li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
